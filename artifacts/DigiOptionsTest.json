{
	"schemaVersion": "2.0.0",
	"contractName": "DigiOptionsTest",
	"compilerOutput": {
		"abi": [
			{
				"inputs": [
					{
						"components": [
							{
								"internalType": "string",
								"name": "underlyingString",
								"type": "string"
							},
							{
								"internalType": "uint40",
								"name": "expirationDatetime",
								"type": "uint40"
							},
							{
								"internalType": "uint24",
								"name": "objectionPeriod",
								"type": "uint24"
							},
							{
								"internalType": "uint8",
								"name": "config",
								"type": "uint8"
							},
							{
								"internalType": "uint8",
								"name": "marketCategory",
								"type": "uint8"
							},
							{
								"internalType": "uint8",
								"name": "baseUnitExp",
								"type": "uint8"
							},
							{
								"internalType": "int8",
								"name": "ndigit",
								"type": "int8"
							},
							{
								"internalType": "address",
								"name": "signerAddr",
								"type": "address"
							},
							{
								"internalType": "uint8",
								"name": "marketInterval",
								"type": "uint8"
							},
							{
								"internalType": "uint8",
								"name": "transactionFee0",
								"type": "uint8"
							},
							{
								"internalType": "uint8",
								"name": "transactionFee1",
								"type": "uint8"
							},
							{
								"internalType": "uint8",
								"name": "transactionFeeSigner",
								"type": "uint8"
							},
							{
								"internalType": "address",
								"name": "feeTaker0",
								"type": "address"
							},
							{
								"internalType": "address",
								"name": "feeTaker1",
								"type": "address"
							},
							{
								"internalType": "int128[]",
								"name": "strikes",
								"type": "int128[]"
							}
						],
						"internalType": "struct DigiOptionsLib.MarketBaseData",
						"name": "marketBaseData",
						"type": "tuple"
					}
				],
				"name": "calcBaseMarketHash",
				"outputs": [
					{
						"internalType": "bytes32",
						"name": "baseMarketHash",
						"type": "bytes32"
					}
				],
				"stateMutability": "pure",
				"type": "function"
			},
			{
				"inputs": [
					{
						"components": [
							{
								"internalType": "string",
								"name": "underlyingString",
								"type": "string"
							},
							{
								"internalType": "uint40",
								"name": "expirationDatetime",
								"type": "uint40"
							},
							{
								"internalType": "uint24",
								"name": "objectionPeriod",
								"type": "uint24"
							},
							{
								"internalType": "uint8",
								"name": "config",
								"type": "uint8"
							},
							{
								"internalType": "uint8",
								"name": "marketCategory",
								"type": "uint8"
							},
							{
								"internalType": "uint8",
								"name": "baseUnitExp",
								"type": "uint8"
							},
							{
								"internalType": "int8",
								"name": "ndigit",
								"type": "int8"
							},
							{
								"internalType": "address",
								"name": "signerAddr",
								"type": "address"
							},
							{
								"internalType": "uint8",
								"name": "marketInterval",
								"type": "uint8"
							},
							{
								"internalType": "uint8",
								"name": "transactionFee0",
								"type": "uint8"
							},
							{
								"internalType": "uint8",
								"name": "transactionFee1",
								"type": "uint8"
							},
							{
								"internalType": "uint8",
								"name": "transactionFeeSigner",
								"type": "uint8"
							},
							{
								"internalType": "address",
								"name": "feeTaker0",
								"type": "address"
							},
							{
								"internalType": "address",
								"name": "feeTaker1",
								"type": "address"
							},
							{
								"internalType": "int128[]",
								"name": "strikes",
								"type": "int128[]"
							}
						],
						"internalType": "struct DigiOptionsLib.MarketBaseData",
						"name": "marketBaseData",
						"type": "tuple"
					}
				],
				"name": "calcFactHashTest",
				"outputs": [
					{
						"internalType": "bytes32",
						"name": "marketHash",
						"type": "bytes32"
					}
				],
				"stateMutability": "pure",
				"type": "function"
			},
			{
				"inputs": [
					{
						"components": [
							{
								"internalType": "string",
								"name": "underlyingString",
								"type": "string"
							},
							{
								"internalType": "uint40",
								"name": "expirationDatetime",
								"type": "uint40"
							},
							{
								"internalType": "uint24",
								"name": "objectionPeriod",
								"type": "uint24"
							},
							{
								"internalType": "uint8",
								"name": "config",
								"type": "uint8"
							},
							{
								"internalType": "uint8",
								"name": "marketCategory",
								"type": "uint8"
							},
							{
								"internalType": "uint8",
								"name": "baseUnitExp",
								"type": "uint8"
							},
							{
								"internalType": "int8",
								"name": "ndigit",
								"type": "int8"
							},
							{
								"internalType": "address",
								"name": "signerAddr",
								"type": "address"
							},
							{
								"internalType": "uint8",
								"name": "marketInterval",
								"type": "uint8"
							},
							{
								"internalType": "uint8",
								"name": "transactionFee0",
								"type": "uint8"
							},
							{
								"internalType": "uint8",
								"name": "transactionFee1",
								"type": "uint8"
							},
							{
								"internalType": "uint8",
								"name": "transactionFeeSigner",
								"type": "uint8"
							},
							{
								"internalType": "address",
								"name": "feeTaker0",
								"type": "address"
							},
							{
								"internalType": "address",
								"name": "feeTaker1",
								"type": "address"
							},
							{
								"internalType": "int128[]",
								"name": "strikes",
								"type": "int128[]"
							}
						],
						"internalType": "struct DigiOptionsLib.MarketBaseData",
						"name": "marketBaseData",
						"type": "tuple"
					}
				],
				"name": "calcMarketHashTest",
				"outputs": [
					{
						"internalType": "bytes32",
						"name": "marketHash",
						"type": "bytes32"
					}
				],
				"stateMutability": "pure",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "uint40",
						"name": "expirationDatetime",
						"type": "uint40"
					}
				],
				"name": "calcMarketIntervalTest",
				"outputs": [
					{
						"internalType": "uint8",
						"name": "interval",
						"type": "uint8"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "uint256",
						"name": "calculatedMarketInterval",
						"type": "uint256"
					}
				],
				"name": "getDividerTest",
				"outputs": [
					{
						"internalType": "uint48",
						"name": "",
						"type": "uint48"
					}
				],
				"stateMutability": "pure",
				"type": "function"
			}
		],
		"evm": {
			"bytecode": {
				"object": "0x608060405234801561001057600080fd5b50610e23806100206000396000f3fe608060405234801561001057600080fd5b50600436106100675760003560e01c8063b8a4bf1f11610050578063b8a4bf1f146100b7578063f5299fda146100e1578063fe0a7fa9146100f457600080fd5b80631dcb4ca91461006c578063b04f77c714610092575b600080fd5b61007f61007a3660046107c4565b610107565b6040519081526020015b60405180910390f35b6100a56100a036600461093d565b610118565b60405160ff9091168152602001610089565b6100ca6100c5366004610958565b610123565b60405165ffffffffffff9091168152602001610089565b61007f6100ef3660046107c4565b61012e565b61007f6101023660046107c4565b610139565b600061011282610144565b92915050565b600061011282610258565b600061011282610347565b60006101128261038a565b60006101128261045c565b60006060826000015160405160200161015d91906109a1565b6040516020818303038152906040528051906020012083602001518460400151856060015186608001518760a001518860c001518961010001518a61018001518b6101a001518c60e001516040516020016101c29b9a999897969594939291906109bd565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152908290526101208501516101408601516101608701516101c088015193955061021b94869490602001610b9d565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081840301815291905280516020909101209392505050565b6000808061026d64ffffffffff851642610577565b90506303c2670081106102e0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f746f6f2066617220696e20746865206675747572650000000000000000000000604482015260640160405180910390fd5b623b53808111156102f55760015b9150610340565b620a8c008111156103075760036102ee565b6201fa408111156103195760046102ee565b611c2081111561032a5760056102ee565b61038481111561033b5760066102ee565b600791505b5092915050565b6000806040518060600160405280602a8152602001610dc4602a9139905060006006610374856001610c3c565b61037e9190610c54565b91909101519392505050565b6000606082600001516040516020016103a391906109a1565b6040516020818303038152906040528051906020012083602001518460400151856060015186608001518760a001518860c001518961010001518a60e001516040516020016103fa99989796959493929190610c91565b604080518083037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0018152919052606084015190915060011661044e576101c083015160405161021b918391602001610d85565b805160209091012092915050565b60006060826000015160405160200161047591906109a1565b604080518083037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe001815282825280516020918201208682015187840151606089015160808a015160a08b015160c08c01519689019590955260d89390931b7fffffffffff000000000000000000000000000000000000000000000000000000169587019590955260e81b7fffffff000000000000000000000000000000000000000000000000000000000016604586015260f893841b7fff00000000000000000000000000000000000000000000000000000000000000908116604887015290841b8116604986015290831b16604a840152901b604b820152604c016103fa565b60006105838284610dac565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040516101e0810167ffffffffffffffff811182821017156105dd576105dd61058a565b60405290565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff8111828210171561062a5761062a61058a565b604052919050565b600082601f83011261064357600080fd5b813567ffffffffffffffff81111561065d5761065d61058a565b61068e60207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116016105e3565b8181528460208386010111156106a357600080fd5b816020850160208301376000918101602001919091529392505050565b803564ffffffffff811681146106d557600080fd5b919050565b803562ffffff811681146106d557600080fd5b803560ff811681146106d557600080fd5b8035600081900b81146106d557600080fd5b803573ffffffffffffffffffffffffffffffffffffffff811681146106d557600080fd5b600082601f83011261074557600080fd5b8135602067ffffffffffffffff8211156107615761076161058a565b8160051b6107708282016105e3565b928352848101820192828101908785111561078a57600080fd5b83870192505b848310156107b957823580600f0b81146107aa5760008081fd5b82529183019190830190610790565b979650505050505050565b6000602082840312156107d657600080fd5b813567ffffffffffffffff808211156107ee57600080fd5b908301906101e0828603121561080357600080fd5b61080b6105b9565b82358281111561081a57600080fd5b61082687828601610632565b825250610835602084016106c0565b6020820152610846604084016106da565b6040820152610857606084016106ed565b6060820152610868608084016106ed565b608082015261087960a084016106ed565b60a082015261088a60c084016106fe565b60c082015261089b60e08401610710565b60e08201526101006108ae8185016106ed565b908201526101206108c08482016106ed565b908201526101406108d28482016106ed565b908201526101606108e48482016106ed565b908201526101806108f6848201610710565b908201526101a0610908848201610710565b908201526101c0838101358381111561092057600080fd5b61092c88828701610734565b918301919091525095945050505050565b60006020828403121561094f57600080fd5b610583826106c0565b60006020828403121561096a57600080fd5b5035919050565b60005b8381101561098c578181015183820152602001610974565b8381111561099b576000848401525b50505050565b600082516109b3818460208701610971565b9190910192915050565b8b81527fffffffffff0000000000000000000000000000000000000000000000000000008b60d81b1660208201527fffffff00000000000000000000000000000000000000000000000000000000008a60e81b16602582015260007fff00000000000000000000000000000000000000000000000000000000000000808b60f81b166028840152808a60f81b16602984015250610a81602a83018960f81b7fff00000000000000000000000000000000000000000000000000000000000000169052565b610a90602b83018860f81b9052565b610ac1602c83018760f81b7fff00000000000000000000000000000000000000000000000000000000000000169052565b610af2602d83018660601b7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000169052565b610b23604183018560601b7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000169052565b610b54605583018460601b7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000169052565b506069019b9a5050505050505050505050565b60008151602080840160005b83811015610b92578151600f0b87529582019590820190600101610b73565b509495945050505050565b60008651610baf818460208b01610971565b80830190507fff00000000000000000000000000000000000000000000000000000000000000808860f81b168252808760f81b166001830152808660f81b16600283015250610c016003820185610b67565b98975050505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60008219821115610c4f57610c4f610c0d565b500190565b6000817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0483118215151615610c8c57610c8c610c0d565b500290565b8981527fffffffffff0000000000000000000000000000000000000000000000000000008960d81b1660208201527fffffff00000000000000000000000000000000000000000000000000000000008860e81b16602582015260007fff00000000000000000000000000000000000000000000000000000000000000808960f81b166028840152808860f81b166029840152808760f81b16602a8401528560f81b602b840152808560f81b16602c84015250610d74602d83018460601b7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000169052565b506041019998505050505050505050565b60008351610d97818460208801610971565b610da381840185610b67565b95945050505050565b600082821015610dbe57610dbe610c0d565b50039056fe000000000000000000fa7d000000003b53800000000a8c0000000001fa40000000001c20000000000000a264697066735822122065ba179567bc8a9a6ee6de4cc2ca4295b4c9d5e467562bdf97039a9574f4844364736f6c634300080c0033",
				"sourceMap": "1695:1185:5:-:0;;;;;;;;;;;;;;;;;;;"
			},
			"deployedBytecode": {
				"object": "0x608060405234801561001057600080fd5b50600436106100675760003560e01c8063b8a4bf1f11610050578063b8a4bf1f146100b7578063f5299fda146100e1578063fe0a7fa9146100f457600080fd5b80631dcb4ca91461006c578063b04f77c714610092575b600080fd5b61007f61007a3660046107c4565b610107565b6040519081526020015b60405180910390f35b6100a56100a036600461093d565b610118565b60405160ff9091168152602001610089565b6100ca6100c5366004610958565b610123565b60405165ffffffffffff9091168152602001610089565b61007f6100ef3660046107c4565b61012e565b61007f6101023660046107c4565b610139565b600061011282610144565b92915050565b600061011282610258565b600061011282610347565b60006101128261038a565b60006101128261045c565b60006060826000015160405160200161015d91906109a1565b6040516020818303038152906040528051906020012083602001518460400151856060015186608001518760a001518860c001518961010001518a61018001518b6101a001518c60e001516040516020016101c29b9a999897969594939291906109bd565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152908290526101208501516101408601516101608701516101c088015193955061021b94869490602001610b9d565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081840301815291905280516020909101209392505050565b6000808061026d64ffffffffff851642610577565b90506303c2670081106102e0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f746f6f2066617220696e20746865206675747572650000000000000000000000604482015260640160405180910390fd5b623b53808111156102f55760015b9150610340565b620a8c008111156103075760036102ee565b6201fa408111156103195760046102ee565b611c2081111561032a5760056102ee565b61038481111561033b5760066102ee565b600791505b5092915050565b6000806040518060600160405280602a8152602001610dc4602a9139905060006006610374856001610c3c565b61037e9190610c54565b91909101519392505050565b6000606082600001516040516020016103a391906109a1565b6040516020818303038152906040528051906020012083602001518460400151856060015186608001518760a001518860c001518961010001518a60e001516040516020016103fa99989796959493929190610c91565b604080518083037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0018152919052606084015190915060011661044e576101c083015160405161021b918391602001610d85565b805160209091012092915050565b60006060826000015160405160200161047591906109a1565b604080518083037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe001815282825280516020918201208682015187840151606089015160808a015160a08b015160c08c01519689019590955260d89390931b7fffffffffff000000000000000000000000000000000000000000000000000000169587019590955260e81b7fffffff000000000000000000000000000000000000000000000000000000000016604586015260f893841b7fff00000000000000000000000000000000000000000000000000000000000000908116604887015290841b8116604986015290831b16604a840152901b604b820152604c016103fa565b60006105838284610dac565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040516101e0810167ffffffffffffffff811182821017156105dd576105dd61058a565b60405290565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff8111828210171561062a5761062a61058a565b604052919050565b600082601f83011261064357600080fd5b813567ffffffffffffffff81111561065d5761065d61058a565b61068e60207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116016105e3565b8181528460208386010111156106a357600080fd5b816020850160208301376000918101602001919091529392505050565b803564ffffffffff811681146106d557600080fd5b919050565b803562ffffff811681146106d557600080fd5b803560ff811681146106d557600080fd5b8035600081900b81146106d557600080fd5b803573ffffffffffffffffffffffffffffffffffffffff811681146106d557600080fd5b600082601f83011261074557600080fd5b8135602067ffffffffffffffff8211156107615761076161058a565b8160051b6107708282016105e3565b928352848101820192828101908785111561078a57600080fd5b83870192505b848310156107b957823580600f0b81146107aa5760008081fd5b82529183019190830190610790565b979650505050505050565b6000602082840312156107d657600080fd5b813567ffffffffffffffff808211156107ee57600080fd5b908301906101e0828603121561080357600080fd5b61080b6105b9565b82358281111561081a57600080fd5b61082687828601610632565b825250610835602084016106c0565b6020820152610846604084016106da565b6040820152610857606084016106ed565b6060820152610868608084016106ed565b608082015261087960a084016106ed565b60a082015261088a60c084016106fe565b60c082015261089b60e08401610710565b60e08201526101006108ae8185016106ed565b908201526101206108c08482016106ed565b908201526101406108d28482016106ed565b908201526101606108e48482016106ed565b908201526101806108f6848201610710565b908201526101a0610908848201610710565b908201526101c0838101358381111561092057600080fd5b61092c88828701610734565b918301919091525095945050505050565b60006020828403121561094f57600080fd5b610583826106c0565b60006020828403121561096a57600080fd5b5035919050565b60005b8381101561098c578181015183820152602001610974565b8381111561099b576000848401525b50505050565b600082516109b3818460208701610971565b9190910192915050565b8b81527fffffffffff0000000000000000000000000000000000000000000000000000008b60d81b1660208201527fffffff00000000000000000000000000000000000000000000000000000000008a60e81b16602582015260007fff00000000000000000000000000000000000000000000000000000000000000808b60f81b166028840152808a60f81b16602984015250610a81602a83018960f81b7fff00000000000000000000000000000000000000000000000000000000000000169052565b610a90602b83018860f81b9052565b610ac1602c83018760f81b7fff00000000000000000000000000000000000000000000000000000000000000169052565b610af2602d83018660601b7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000169052565b610b23604183018560601b7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000169052565b610b54605583018460601b7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000169052565b506069019b9a5050505050505050505050565b60008151602080840160005b83811015610b92578151600f0b87529582019590820190600101610b73565b509495945050505050565b60008651610baf818460208b01610971565b80830190507fff00000000000000000000000000000000000000000000000000000000000000808860f81b168252808760f81b166001830152808660f81b16600283015250610c016003820185610b67565b98975050505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60008219821115610c4f57610c4f610c0d565b500190565b6000817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0483118215151615610c8c57610c8c610c0d565b500290565b8981527fffffffffff0000000000000000000000000000000000000000000000000000008960d81b1660208201527fffffff00000000000000000000000000000000000000000000000000000000008860e81b16602582015260007fff00000000000000000000000000000000000000000000000000000000000000808960f81b166028840152808860f81b166029840152808760f81b16602a8401528560f81b602b840152808560f81b16602c84015250610d74602d83018460601b7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000169052565b506041019998505050505050505050565b60008351610d97818460208801610971565b610da381840185610b67565b95945050505050565b600082821015610dbe57610dbe610c0d565b50039056fe000000000000000000fa7d000000003b53800000000a8c0000000001fa40000000001c20000000000000a264697066735822122065ba179567bc8a9a6ee6de4cc2ca4295b4c9d5e467562bdf97039a9574f4844364736f6c634300080c0033",
				"sourceMap": "1695:1185:5:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2173:234;;;;;;:::i;:::-;;:::i;:::-;;;5075:25:11;;;5063:2;5048:18;2173:234:5;;;;;;;;2661:216;;;;;;:::i;:::-;;:::i;:::-;;;5472:4:11;5460:17;;;5442:36;;5430:2;5415:18;2661:216:5;5300:184:11;1727:204:5;;;;;;:::i;:::-;;:::i;:::-;;;5848:14:11;5836:27;;;5818:46;;5806:2;5791:18;1727:204:5;5674:196:11;2413:242:5;;;;;;:::i;:::-;;:::i;1937:230::-;;;;;;:::i;:::-;;:::i;2173:234::-;2314:18;2355:45;2385:14;2355:29;:45::i;:::-;2348:52;2173:234;-1:-1:-1;;2173:234:5:o;2661:216::-;2780:14;2817:53;2851:18;2817:33;:53::i;1727:204::-;1844:6;1873:51;1899:24;1873:25;:51::i;2413:242::-;2554:22;2599:49;2633:14;2599:33;:49::i;1937:230::-;2076:18;2117:43;2145:14;2117:27;:43::i;7468:1285:1:-;7607:18;7641:17;7767:14;:31;;;7750:49;;;;;;;;:::i;:::-;;;;;;;;;;;;;7740:60;;;;;;7840:14;:33;;;7929:14;:30;;;7997:14;:21;;;8032:14;:29;;;8076:14;:26;;;8173:14;:21;;;8259:14;:29;;;8302:14;:24;;;8340:14;:24;;;8378:14;:25;;;7675:805;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;8545:30;;;;8589;;;;8633:35;;;;8682:22;;;;7675:805;;-1:-1:-1;8497:217:1;;7675:805;;8682:22;7675:805;8497:217;;:::i;:::-;;;;;;;;;;;;;;8731:15;;8497:217;8731:15;;;;;7468:1285;-1:-1:-1;;;7468:1285:1:o;5026:1240::-;5143:14;;;5236:57;:27;;;5276:15;5236:31;:57::i;:::-;5203:90;;5362:18;5337:22;:43;5329:77;;;;;;;9361:2:11;5329:77:1;;;9343:21:11;9400:2;9380:18;;;9373:30;9439:23;9419:18;;;9412:51;9480:18;;5329:77:1;;;;;;;;5445:17;5420:22;:42;5416:811;;;5512:39;5506:46;5489:63;;5416:811;;;5596:16;5571:22;:41;5567:660;;;5661:40;5655:47;;5567:660;5746:12;5721:22;:37;5717:510;;;5809:39;5803:46;;5717:510;5893:11;5868:22;:36;5864:363;;;5954:38;5948:45;;5864:363;6037:7;6012:22;:32;6008:219;;;6093:39;6087:46;;6008:219;6183:43;6160:67;;6008:219;-1:-1:-1;6245:14:1;5026:1240;-1:-1:-1;;5026:1240:1:o;4548:375::-;4663:6;4685:18;4706:13;;;;;;;;;;;;;;;;;4685:34;-1:-1:-1;4729:11:1;4317:1;4744:28;:24;4771:1;4744:28;:::i;:::-;4743:52;;;;:::i;:::-;4865:18;;;;4859:25;;4548:375;-1:-1:-1;;;4548:375:1:o;8759:1331::-;8887:22;9066:17;9157:14;:31;;;9140:49;;;;;;;;:::i;:::-;;;;;;;;;;;;;9130:60;;;;;;9230:14;:33;;;9319:14;:30;;;9387:14;:21;;;9422:14;:29;;;9466:14;:26;;;9563:14;:21;;;9649:14;:29;;;9693:14;:25;;;9100:628;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;9830:21;;;;9100:628;;-1:-1:-1;9860:58:1;9830:89;9825:226;;10004:22;;;;9948:92;;;;9982:4;;9948:92;;;:::i;9825:226::-;10067:15;;;;;;;;8759:1331;-1:-1:-1;;8759:1331:1:o;6272:1190::-;6491:16;6523:17;6614:14;:31;;;6597:49;;;;;;;;:::i;:::-;;;;;;;;;;;;;;6587:60;;6597:49;6587:60;;;;6687:33;;;;6776:30;;;;6844:21;;;;6879:29;;;;6923:26;;;;7020:21;;;;6557:544;;;11950:19:11;;;;12007:3;12003:16;;;;12021:66;11999:89;11985:12;;;11978:111;;;;12127:3;12123:16;12141:66;12119:89;12105:12;;;12098:111;12332:3;12328:16;;;12228:66;12324:25;;;12310:12;;;12303:47;12384:16;;;12380:25;;12366:12;;;12359:47;12440:16;;;12436:25;12422:12;;;12415:47;12492:16;;12478:12;;;12471:38;12525:12;;6557:544:1;11675:868:11;3122:96:7;3180:7;3206:5;3210:1;3206;:5;:::i;:::-;3199:12;3122:96;-1:-1:-1;;;3122:96:7:o;14:184:11:-;66:77;63:1;56:88;163:4;160:1;153:15;187:4;184:1;177:15;203:255;275:2;269:9;317:6;305:19;;354:18;339:34;;375:22;;;336:62;333:88;;;401:18;;:::i;:::-;437:2;430:22;203:255;:::o;463:334::-;534:2;528:9;590:2;580:13;;595:66;576:86;564:99;;693:18;678:34;;714:22;;;675:62;672:88;;;740:18;;:::i;:::-;776:2;769:22;463:334;;-1:-1:-1;463:334:11:o;802:590::-;845:5;898:3;891:4;883:6;879:17;875:27;865:55;;916:1;913;906:12;865:55;952:6;939:20;978:18;974:2;971:26;968:52;;;1000:18;;:::i;:::-;1044:114;1152:4;1083:66;1076:4;1072:2;1068:13;1064:86;1060:97;1044:114;:::i;:::-;1183:2;1174:7;1167:19;1229:3;1222:4;1217:2;1209:6;1205:15;1201:26;1198:35;1195:55;;;1246:1;1243;1236:12;1195:55;1311:2;1304:4;1296:6;1292:17;1285:4;1276:7;1272:18;1259:55;1359:1;1334:16;;;1352:4;1330:27;1323:38;;;;1338:7;802:590;-1:-1:-1;;;802:590:11:o;1397:165::-;1464:20;;1524:12;1513:24;;1503:35;;1493:63;;1552:1;1549;1542:12;1493:63;1397:165;;;:::o;1567:161::-;1634:20;;1694:8;1683:20;;1673:31;;1663:59;;1718:1;1715;1708:12;1733:156;1799:20;;1859:4;1848:16;;1838:27;;1828:55;;1879:1;1876;1869:12;1894:159;1959:20;;1930:5;2008:20;;;1998:31;;1988:59;;2043:1;2040;2033:12;2058:196;2126:20;;2186:42;2175:54;;2165:65;;2155:93;;2244:1;2241;2234:12;2259:885;2312:5;2365:3;2358:4;2350:6;2346:17;2342:27;2332:55;;2383:1;2380;2373:12;2332:55;2419:6;2406:20;2445:4;2468:18;2464:2;2461:26;2458:52;;;2490:18;;:::i;:::-;2536:2;2533:1;2529:10;2559:28;2583:2;2579;2575:11;2559:28;:::i;:::-;2621:15;;;2691;;;2687:24;;;2652:12;;;;2723:15;;;2720:35;;;2751:1;2748;2741:12;2720:35;2787:2;2779:6;2775:15;2764:26;;2799:316;2815:6;2810:3;2807:15;2799:316;;;2895:3;2882:17;2947:5;2943:2;2932:21;2925:5;2922:32;2912:130;;2996:1;3025:2;3021;3014:14;2912:130;3055:18;;2832:12;;;;3093;;;;2799:316;;;3133:5;2259:885;-1:-1:-1;;;;;;;2259:885:11:o;3149:1775::-;3239:6;3292:2;3280:9;3271:7;3267:23;3263:32;3260:52;;;3308:1;3305;3298:12;3260:52;3348:9;3335:23;3377:18;3418:2;3410:6;3407:14;3404:34;;;3434:1;3431;3424:12;3404:34;3457:22;;;;3513:6;3495:16;;;3491:29;3488:49;;;3533:1;3530;3523:12;3488:49;3559:22;;:::i;:::-;3619:2;3606:16;3647:2;3637:8;3634:16;3631:36;;;3663:1;3660;3653:12;3631:36;3690:45;3727:7;3716:8;3712:2;3708:17;3690:45;:::i;:::-;3683:5;3676:60;;3768:30;3794:2;3790;3786:11;3768:30;:::i;:::-;3763:2;3756:5;3752:14;3745:54;3831:30;3857:2;3853;3849:11;3831:30;:::i;:::-;3826:2;3819:5;3815:14;3808:54;3894:29;3919:2;3915;3911:11;3894:29;:::i;:::-;3889:2;3882:5;3878:14;3871:53;3957:30;3982:3;3978:2;3974:12;3957:30;:::i;:::-;3951:3;3944:5;3940:15;3933:55;4021:30;4046:3;4042:2;4038:12;4021:30;:::i;:::-;4015:3;4008:5;4004:15;3997:55;4085:29;4109:3;4105:2;4101:12;4085:29;:::i;:::-;4079:3;4072:5;4068:15;4061:54;4148:32;4175:3;4171:2;4167:12;4148:32;:::i;:::-;4142:3;4135:5;4131:15;4124:57;4200:3;4235:29;4260:2;4256;4252:11;4235:29;:::i;:::-;4219:14;;;4212:53;4284:3;4319:29;4336:11;;;4319:29;:::i;:::-;4303:14;;;4296:53;4368:3;4403:29;4420:11;;;4403:29;:::i;:::-;4387:14;;;4380:53;4452:3;4487:29;4504:11;;;4487:29;:::i;:::-;4471:14;;;4464:53;4536:3;4571:31;4590:11;;;4571:31;:::i;:::-;4555:14;;;4548:55;4622:3;4657:31;4676:11;;;4657:31;:::i;:::-;4641:14;;;4634:55;4708:3;4749:11;;;4736:25;4773:16;;;4770:36;;;4802:1;4799;4792:12;4770:36;4838:55;4885:7;4874:8;4870:2;4866:17;4838:55;:::i;:::-;4822:14;;;4815:79;;;;-1:-1:-1;4826:5:11;3149:1775;-1:-1:-1;;;;;3149:1775:11:o;5111:184::-;5169:6;5222:2;5210:9;5201:7;5197:23;5193:32;5190:52;;;5238:1;5235;5228:12;5190:52;5261:28;5279:9;5261:28;:::i;5489:180::-;5548:6;5601:2;5589:9;5580:7;5576:23;5572:32;5569:52;;;5617:1;5614;5607:12;5569:52;-1:-1:-1;5640:23:11;;5489:180;-1:-1:-1;5489:180:11:o;5875:258::-;5947:1;5957:113;5971:6;5968:1;5965:13;5957:113;;;6047:11;;;6041:18;6028:11;;;6021:39;5993:2;5986:10;5957:113;;;6088:6;6085:1;6082:13;6079:48;;;6123:1;6114:6;6109:3;6105:16;6098:27;6079:48;;5875:258;;;:::o;6138:276::-;6269:3;6307:6;6301:13;6323:53;6369:6;6364:3;6357:4;6349:6;6345:17;6323:53;:::i;:::-;6392:16;;;;;6138:276;-1:-1:-1;;6138:276:11:o;6826:1163::-;7222:6;7217:3;7210:19;7281:66;7272:6;7267:3;7263:16;7259:89;7254:2;7249:3;7245:12;7238:111;7401:66;7392:6;7387:3;7383:16;7379:89;7374:2;7369:3;7365:12;7358:111;7192:3;7488:66;7606:2;7597:6;7592:3;7588:16;7584:25;7579:2;7574:3;7570:12;7563:47;7662:2;7653:6;7648:3;7644:16;7640:25;7635:2;7630:3;7626:12;7619:47;;7675:38;7709:2;7704:3;7700:12;7692:6;6491:3;6487:15;6504:66;6483:88;6471:101;;6419:159;7675:38;7722:37;7755:2;7750:3;7746:12;7738:6;6642:3;6638:15;6626:28;;6583:73;7722:37;7768:38;7802:2;7797:3;7793:12;7785:6;6491:3;6487:15;6504:66;6483:88;6471:101;;6419:159;7768:38;7815:40;7851:2;7846:3;7842:12;7834:6;6735:2;6731:14;6747:66;6727:87;6715:100;;6661:160;7815:40;7864;7900:2;7895:3;7891:12;7883:6;6735:2;6731:14;6747:66;6727:87;6715:100;;6661:160;7864:40;7913:41;7950:2;7945:3;7941:12;7932:7;6735:2;6731:14;6747:66;6727:87;6715:100;;6661:160;7913:41;-1:-1:-1;7979:3:11;7970:13;;6826:1163;-1:-1:-1;;;;;;;;;;;6826:1163:11:o;7994:413::-;8046:3;8084:5;8078:12;8128:4;8166:2;8159:5;8155:14;8187:1;8197:185;8211:6;8208:1;8205:13;8197:185;;;8287:13;;8283:2;8272:29;8260:42;;8322:12;;;;8357:15;;;;8233:1;8226:9;8197:185;;;-1:-1:-1;8398:3:11;;7994:413;-1:-1:-1;;;;;7994:413:11:o;8412:742::-;8689:3;8727:6;8721:13;8743:53;8789:6;8784:3;8777:4;8769:6;8765:17;8743:53;:::i;:::-;8827:6;8822:3;8818:16;8805:29;;8853:66;8964:2;8955:6;8950:3;8946:16;8942:25;8935:5;8928:40;9021:2;9012:6;9007:3;9003:16;8999:25;8995:1;8988:5;8984:13;8977:48;9078:2;9069:6;9064:3;9060:16;9056:25;9052:1;9045:5;9041:13;9034:48;;9098:50;9145:1;9138:5;9134:13;9126:6;9098:50;:::i;:::-;9091:57;8412:742;-1:-1:-1;;;;;;;;8412:742:11:o;9698:184::-;9750:77;9747:1;9740:88;9847:4;9844:1;9837:15;9871:4;9868:1;9861:15;9887:128;9927:3;9958:1;9954:6;9951:1;9948:13;9945:39;;;9964:18;;:::i;:::-;-1:-1:-1;10000:9:11;;9887:128::o;10020:228::-;10060:7;10186:1;10118:66;10114:74;10111:1;10108:81;10103:1;10096:9;10089:17;10085:105;10082:131;;;10193:18;;:::i;:::-;-1:-1:-1;10233:9:11;;10020:228::o;10253:1025::-;10592:6;10587:3;10580:19;10651:66;10642:6;10637:3;10633:16;10629:89;10624:2;10619:3;10615:12;10608:111;10771:66;10762:6;10757:3;10753:16;10749:89;10744:2;10739:3;10735:12;10728:111;10562:3;10858:66;10976:2;10967:6;10962:3;10958:16;10954:25;10949:2;10944:3;10940:12;10933:47;11032:2;11023:6;11018:3;11014:16;11010:25;11005:2;11000:3;10996:12;10989:47;11088:2;11079:6;11074:3;11070:16;11066:25;11061:2;11056:3;11052:12;11045:47;11131:6;11126:3;11122:16;11117:2;11112:3;11108:12;11101:38;11191:2;11182:6;11177:3;11173:16;11169:25;11164:2;11159:3;11155:12;11148:47;;11204:40;11240:2;11235:3;11231:12;11223:6;6735:2;6731:14;6747:66;6727:87;6715:100;;6661:160;11204:40;-1:-1:-1;11269:2:11;11260:12;;10253:1025;-1:-1:-1;;;;;;;;;10253:1025:11:o;11283:387::-;11488:3;11526:6;11520:13;11542:53;11588:6;11583:3;11576:4;11568:6;11564:17;11542:53;:::i;:::-;11611;11656:6;11651:3;11647:16;11639:6;11611:53;:::i;:::-;11604:60;11283:387;-1:-1:-1;;;;;11283:387:11:o;12548:125::-;12588:4;12616:1;12613;12610:8;12607:34;;;12621:18;;:::i;:::-;-1:-1:-1;12658:9:11;;12548:125::o"
			}
		}
	},
	"sourceTreeHashHex": "0x8717e112e35722892e5b545583295d53bc3e4f85ab2ef197ece977db5ab90974",
	"sources": {
		"./DigiOptionsTest.sol": {
			"id": 5,
			"content": "/*\n User Driven Option Markets Contract used by https://www.digioptions.com\n\n This is just a helper to test internal functions which are not\n exposed from main contracts.\n\n Copyright (c) [www.digioptions.com](https://www.digioptions.com)\n\n Designed to work with signatures from [www.factsigner.com](https://www.factsigner.com)\n\n Public repository:\n https://github.com/berlincode/digioptions-contracts.js\n\n elastic.code@gmail.com\n mail@digioptions.com\n\n SPDX-License-Identifier: MIT\n\n MIT License\n\n Copyright (c) digioptions.com (https://www.digioptions.com)\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all\n copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.\n\n*/\n\npragma solidity >=0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./DigiOptionsLib.sol\";\n\n\ncontract DigiOptionsTest {\n\n    function getDividerTest(\n        uint256 calculatedMarketInterval\n    )\n        public\n        pure\n        returns (uint48)\n    {\n        return DigiOptionsLib.getDivider(calculatedMarketInterval);\n    }\n\n    function calcFactHashTest (\n        DigiOptionsLib.MarketBaseData memory marketBaseData\n    )\n        public\n        pure\n        returns (bytes32 marketHash)\n    {\n        return DigiOptionsLib.calcFactHash(marketBaseData);\n    }\n\n    function calcMarketHashTest (\n        DigiOptionsLib.MarketBaseData memory marketBaseData\n    )\n        public\n        pure\n        returns (bytes32 marketHash)\n    {\n        return DigiOptionsLib.calcMarketHash(marketBaseData);\n    }\n\n    function calcBaseMarketHash (\n        DigiOptionsLib.MarketBaseData memory marketBaseData\n    )\n        public\n        pure\n        returns (bytes32 baseMarketHash)\n    {\n        return DigiOptionsLib.calcBaseMarketHash(marketBaseData);\n    }\n\n    function calcMarketIntervalTest (\n        uint40 expirationDatetime\n    )\n        public\n        view\n        returns (uint8 interval)\n    {\n        return DigiOptionsLib.calcMarketInterval(expirationDatetime);\n    }\n\n}\n"
		},
		"./DigiOptionsLib.sol": {
			"id": 1,
			"content": "/*\n\n Public repository:\n https://github.com/berlincode/digioptions-contracts.js\n\n elastic.code@gmail.com\n mail@digioptions.com\n\n SPDX-License-Identifier: MIT\n\n MIT License\n\n Copyright (c) digioptions.com (https://www.digioptions.com)\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all\n copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.\n\n*/\n\npragma solidity >=0.7.0;\n\nimport \"factsigner/contracts/FactsignerDefines.sol\";\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n//import \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\n\n\nlibrary DigiOptionsLib {\n    using SafeMath for uint256;\n\n    /*\n        For future updgrade we want getContractInfo() to remain its signature('getContractInfo(uint256[]')\n        so we declared the return values as dynamic list. The meaning of each entry is defined via\n        follwing enum.\n    */\n    enum InfoValues { // rename InfoContract\n        CONTRACT_TYPE_IDX, // 0\n        VERSION_MARKET_LISTER_IDX, // 1\n        VERSION_MARKETS_IDX, // 2\n        DIGIOPTIONS_MARKETS_ADDR_IDX, // 3\n        BLOCK_NUMBER_CREATED_IDX, // 4\n        TIMESTAMP_CREATED_MARKETS_IDX, // 5\n        OFFER_MAX_BLOCKS_INTO_FUTURE_IDX, // 6\n        ATOMIC_OPTION_PAYOUT_WEI_EXP_IDX, // 7\n        EXISTING_MARKETS_IDX, // 8\n\n        MAX // meta info\n    }\n\n    enum InfoLister {\n        VERSION_MARKET_LISTER_IDX, // 0\n        OWNER_IDX,\n        TRANSACTION_FEE_TOTAL_MAX_IDX,\n        TRANSACTION_FEE0_MIN_IDX,\n        TRANSACTION_FEE1_MIN_IDX,\n        TRANSACTION_FEE_SIGNER_MIN_IDX,\n        OPEN_DELAY_SECONDS_IDX,\n\n        MAX // meta info\n    }\n\n    enum ContractType {\n        UNKNOWN,\n        DIGIOPTIONSMARKETS, // == 1\n        DIGIOPTIONSMARKETLISTER // == 2\n    }\n\n    enum UserState {\n        NONE,\n        EXISTS,\n        PAYED_OUT\n    }\n\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct MarketBaseData {\n        /* constant core market data, part of marketHash calculation */\n\n        string underlyingString;\n        uint40 expirationDatetime; /* used for sorting contracts */\n        uint24 objectionPeriod; /* e.g. 3600 seconds */\n\n        uint8 config;\n        uint8 marketCategory;\n\n        uint8 baseUnitExp;\n        int8 ndigit;\n\n        address signerAddr; /* address used to check the signed result (e.g. of factsigner) */\n\n        uint8 marketInterval;\n        uint8 transactionFee0; /* fee in 1/100 per cent (payed by orderTaker) */\n        uint8 transactionFee1; /* fee in 1/100 per cent (payed by orderTaker) */\n        uint8 transactionFeeSigner; /* fee in 1/100 per cent (payed by orderTaker) */\n        address feeTaker0;\n        address feeTaker1;\n        int128[] strikes;\n    }\n\n    struct MarketState {\n        /* winningOptionID is only valid if settled == true */\n        uint128 fee; // total payed fee (for all fee takers)\n        uint16 winningOptionID;\n        bool settled;\n    }\n\n    struct MarketData {\n        MarketBaseData marketBaseData;\n        MarketState marketState;\n        bytes32 marketHash;\n        UserState userState;\n        bool testMarket; // only used by MarketLister\n    }\n\n\n// TODO remove long term? (and add 2-year?)\n// TODO remove uint8() conversion\n// TODO time offset between marketsContract and marketListerContract?\n\n    /* until const arrays are supported in solidity we use our custom function */\n    uint256 constant DIVIDER_ENTRY_BYTES = 6;\n    bytes constant DIVIDER_TABLE = \"\\\n\\x00\\x00\\x00\\x00\\x00\\x00\\\n\\x00\\x00\\x00\\xfa\\x7d\\x00\\\n\\x00\\x00\\x00\\x3b\\x53\\x80\\\n\\x00\\x00\\x00\\x0a\\x8c\\x00\\\n\\x00\\x00\\x00\\x01\\xfa\\x40\\\n\\x00\\x00\\x00\\x00\\x1c\\x20\\\n\\x00\\x00\\x00\\x00\\x00\\x00\\\n\";\n\n    function getDivider(\n        uint256 calculatedMarketInterval\n    )\n        internal\n        pure\n        returns (uint48)\n    {\n        bytes memory table = DIVIDER_TABLE;\n        uint offset = (calculatedMarketInterval + 1) * DIVIDER_ENTRY_BYTES;\n        uint48 value;\n        assembly {\n            value := mload(add(table, offset))\n        }\n\n        return value;\n    }\n\n\n    // TODO this is only 'view' and not internal because of block.timestamp - maybe change that\n    function calcMarketInterval (\n        uint40 expirationDatetime\n    )\n        internal\n        view\n        returns (uint8 interval)\n    {\n        uint8 marketInterval;\n        uint256 secondsUntilExpiration = uint256(expirationDatetime).sub(uint256(block.timestamp));\n        // TODO > or >= ?\n        require(secondsUntilExpiration < 730 * 24 * 60 * 60, \"too far in the future\");\n        if (secondsUntilExpiration > 45 * 24 * 60 * 60) // > 45 days\n            marketInterval = uint8(FactsignerDefines.MarketInterval.YEARLY);\n        else if (secondsUntilExpiration > 8 * 24 * 60 * 60) // > 8 days\n            marketInterval = uint8(FactsignerDefines.MarketInterval.MONTHLY);\n        else if (secondsUntilExpiration > 36 * 60 * 60) // > 36 hours\n            marketInterval = uint8(FactsignerDefines.MarketInterval.WEEKLY);\n        else if (secondsUntilExpiration > 2 * 60 * 60) // > 2 hours\n            marketInterval = uint8(FactsignerDefines.MarketInterval.DAILY);\n        else if (secondsUntilExpiration > 15 * 60) // > 15 min\n            marketInterval = uint8(FactsignerDefines.MarketInterval.HOURLY);\n        else\n            marketInterval = uint8(FactsignerDefines.MarketInterval.SHORT_TERM);\n\n        return marketInterval;\n    }\n\n    function calcFactHash (\n        DigiOptionsLib.MarketBaseData memory marketBaseData\n    )\n        internal\n        pure // this should be external (see https://github.com/ethereum/solidity/issues/5479)\n        returns (bytes32 factHash)\n    {\n        bytes memory data;\n        data = abi.encodePacked(\n            keccak256(abi.encodePacked(marketBaseData.underlyingString)), /* 'name' utf8 encoded */\n            marketBaseData.expirationDatetime, /* 'settlement' unix epoch seconds UTC */\n            marketBaseData.objectionPeriod, /* e.g. 3600 seconds */\n            marketBaseData.config,\n            marketBaseData.marketCategory,\n\n            marketBaseData.baseUnitExp, /* e.g. 18 -> baseUnit = 10**18 = 1000000000000000000 */\n            marketBaseData.ndigit /* 'ndigit' number of digits (may be negative) */\n        );\n        // if this is a named market we simply use strikes as factsigner's namedRanges\n        if ((marketBaseData.config & uint8(FactsignerDefines.ConfigMask.ConfigMarketTypeIsStrikedMask) == 0)) {\n            data = abi.encodePacked(\n                data,\n                marketBaseData.strikes\n            );\n        }\n        return keccak256(data);\n    }\n\n    function calcMarketHash (\n        DigiOptionsLib.MarketBaseData memory marketBaseData\n    )\n        internal\n        pure\n        returns (bytes32 marketHash)\n    {\n        bytes memory data;\n        data = abi.encodePacked(\n            // TODO from facthash?\n            keccak256(abi.encodePacked(marketBaseData.underlyingString)), /* 'name' utf8 encoded */\n            marketBaseData.expirationDatetime, /* 'settlement' unix epoch seconds UTC */\n            marketBaseData.objectionPeriod, /* e.g. 3600 seconds */\n            marketBaseData.config,\n            marketBaseData.marketCategory,\n\n            marketBaseData.baseUnitExp, /* e.g. 18 -> baseUnit = 10**18 = 1000000000000000000 */\n            marketBaseData.ndigit, /* 'ndigit' number of digits (may be negative) */\n\n            marketBaseData.marketInterval,\n            marketBaseData.feeTaker0,\n            marketBaseData.feeTaker1,\n            marketBaseData.signerAddr /* address used to check the signed result (e.g. of factsigner) */\n        );\n        data = abi.encodePacked(\n            data,\n            marketBaseData.transactionFee0,\n            marketBaseData.transactionFee1,\n            marketBaseData.transactionFeeSigner,\n            marketBaseData.strikes\n        );\n        return keccak256(data);\n    }\n\n    function calcBaseMarketHash (\n        MarketBaseData memory marketBaseData\n    )\n        internal\n        pure\n        returns (bytes32 baseMarketHash)\n    {\n        /* baseMarketHash is similar to marketHash but does not contain all elements. It's basically a factHash with added marketInterval */\n        bytes memory data;\n        data = abi.encodePacked(\n            keccak256(abi.encodePacked(marketBaseData.underlyingString)), /* 'name' utf8 encoded */\n            marketBaseData.expirationDatetime, /* 'settlement' unix epoch seconds UTC */\n            marketBaseData.objectionPeriod, /* e.g. 3600 seconds */\n            marketBaseData.config,\n            marketBaseData.marketCategory,\n\n            marketBaseData.baseUnitExp, /* e.g. 18 -> baseUnit = 10**18 = 1000000000000000000 */\n            marketBaseData.ndigit, /* 'ndigit' number of digits (may be negative) */\n\n            marketBaseData.marketInterval,\n\n            marketBaseData.signerAddr\n        );\n        // if this is a named market we simply use strikes as factsigner's namedRanges\n        if ((marketBaseData.config & uint8(FactsignerDefines.ConfigMask.ConfigMarketTypeIsStrikedMask) == 0)) {\n            data = abi.encodePacked(\n                data,\n                marketBaseData.strikes\n            );\n        }\n        return keccak256(data);\n\n    }\n\n\n    bytes constant OFFER_PREFIX = \"\\x19Ethereum Signed Message:\\n32\"; // TODO\n    function verifyOffer(\n        bytes32 message,\n        Signature memory signature\n    )\n        internal\n        pure\n        returns (address addr)\n    {\n        bytes32 prefixedHash = keccak256(\n            abi.encodePacked(\n                OFFER_PREFIX,\n                message\n            )\n        );\n        address signer = ecrecover(\n            prefixedHash,\n            signature.v,\n            signature.r,\n            signature.s\n        );\n        return signer;\n    }\n}\n"
		},
		"factsigner/contracts/FactsignerDefines.sol": {
			"id": 9,
			"content": "/*\n Contract defines for https://www.factsigner.com\n\n Public repository:\n https://github.com/berlincode/factsigner\n\n Version 7.0.0\n\n SPDX-License-Identifier: MIT\n\n MIT License\n\n Copyright (c) factsigner.com (https://www.factsigner.com)\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all\n copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.\n\n*/\n\npragma solidity >=0.7.0;\n\nlibrary FactsignerDefines\n{\n    // TODO we use a enum here as a hack until\n    // https://github.com/ethereum/solidity/issues/1290 is solved\n    enum ConfigMask {\n        ConfigMaskDummy0,\n        ConfigMarketTypeIsStrikedMask, // = 1\n        ConfigMaskDummy2,\n        ConfigMaskDummy3,\n        ConfigIntervalTypeIsUsedMask // = 4\n    }\n\n    enum SettlementType {\n        FINAL, // = 0\n        PRELIMINARY_FIRST // = 1\n        //PRELIMINARY_MAX // = 65535\n    }\n\n    enum MarketInterval {\n        NONE, // = 0\n        // the following constants are just proposed assignments\n        YEARLY, // = 1\n        QUATERLY, // 2\n        MONTHLY, // = 3\n        WEEKLY, // = 4\n        DAILY, // = 5\n        HOURLY, // = 6\n        SHORT_TERM // = 7\n    }\n\n}\n"
		},
		"@openzeppelin/contracts/utils/math/SafeMath.sol": {
			"id": 7,
			"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
		}
	},
	"sourceCodes": {
		"./DigiOptionsTest.sol": "/*\n User Driven Option Markets Contract used by https://www.digioptions.com\n\n This is just a helper to test internal functions which are not\n exposed from main contracts.\n\n Copyright (c) [www.digioptions.com](https://www.digioptions.com)\n\n Designed to work with signatures from [www.factsigner.com](https://www.factsigner.com)\n\n Public repository:\n https://github.com/berlincode/digioptions-contracts.js\n\n elastic.code@gmail.com\n mail@digioptions.com\n\n SPDX-License-Identifier: MIT\n\n MIT License\n\n Copyright (c) digioptions.com (https://www.digioptions.com)\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all\n copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.\n\n*/\n\npragma solidity >=0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./DigiOptionsLib.sol\";\n\n\ncontract DigiOptionsTest {\n\n    function getDividerTest(\n        uint256 calculatedMarketInterval\n    )\n        public\n        pure\n        returns (uint48)\n    {\n        return DigiOptionsLib.getDivider(calculatedMarketInterval);\n    }\n\n    function calcFactHashTest (\n        DigiOptionsLib.MarketBaseData memory marketBaseData\n    )\n        public\n        pure\n        returns (bytes32 marketHash)\n    {\n        return DigiOptionsLib.calcFactHash(marketBaseData);\n    }\n\n    function calcMarketHashTest (\n        DigiOptionsLib.MarketBaseData memory marketBaseData\n    )\n        public\n        pure\n        returns (bytes32 marketHash)\n    {\n        return DigiOptionsLib.calcMarketHash(marketBaseData);\n    }\n\n    function calcBaseMarketHash (\n        DigiOptionsLib.MarketBaseData memory marketBaseData\n    )\n        public\n        pure\n        returns (bytes32 baseMarketHash)\n    {\n        return DigiOptionsLib.calcBaseMarketHash(marketBaseData);\n    }\n\n    function calcMarketIntervalTest (\n        uint40 expirationDatetime\n    )\n        public\n        view\n        returns (uint8 interval)\n    {\n        return DigiOptionsLib.calcMarketInterval(expirationDatetime);\n    }\n\n}\n",
		"./DigiOptionsLib.sol": "/*\n\n Public repository:\n https://github.com/berlincode/digioptions-contracts.js\n\n elastic.code@gmail.com\n mail@digioptions.com\n\n SPDX-License-Identifier: MIT\n\n MIT License\n\n Copyright (c) digioptions.com (https://www.digioptions.com)\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all\n copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.\n\n*/\n\npragma solidity >=0.7.0;\n\nimport \"factsigner/contracts/FactsignerDefines.sol\";\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n//import \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\n\n\nlibrary DigiOptionsLib {\n    using SafeMath for uint256;\n\n    /*\n        For future updgrade we want getContractInfo() to remain its signature('getContractInfo(uint256[]')\n        so we declared the return values as dynamic list. The meaning of each entry is defined via\n        follwing enum.\n    */\n    enum InfoValues { // rename InfoContract\n        CONTRACT_TYPE_IDX, // 0\n        VERSION_MARKET_LISTER_IDX, // 1\n        VERSION_MARKETS_IDX, // 2\n        DIGIOPTIONS_MARKETS_ADDR_IDX, // 3\n        BLOCK_NUMBER_CREATED_IDX, // 4\n        TIMESTAMP_CREATED_MARKETS_IDX, // 5\n        OFFER_MAX_BLOCKS_INTO_FUTURE_IDX, // 6\n        ATOMIC_OPTION_PAYOUT_WEI_EXP_IDX, // 7\n        EXISTING_MARKETS_IDX, // 8\n\n        MAX // meta info\n    }\n\n    enum InfoLister {\n        VERSION_MARKET_LISTER_IDX, // 0\n        OWNER_IDX,\n        TRANSACTION_FEE_TOTAL_MAX_IDX,\n        TRANSACTION_FEE0_MIN_IDX,\n        TRANSACTION_FEE1_MIN_IDX,\n        TRANSACTION_FEE_SIGNER_MIN_IDX,\n        OPEN_DELAY_SECONDS_IDX,\n\n        MAX // meta info\n    }\n\n    enum ContractType {\n        UNKNOWN,\n        DIGIOPTIONSMARKETS, // == 1\n        DIGIOPTIONSMARKETLISTER // == 2\n    }\n\n    enum UserState {\n        NONE,\n        EXISTS,\n        PAYED_OUT\n    }\n\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct MarketBaseData {\n        /* constant core market data, part of marketHash calculation */\n\n        string underlyingString;\n        uint40 expirationDatetime; /* used for sorting contracts */\n        uint24 objectionPeriod; /* e.g. 3600 seconds */\n\n        uint8 config;\n        uint8 marketCategory;\n\n        uint8 baseUnitExp;\n        int8 ndigit;\n\n        address signerAddr; /* address used to check the signed result (e.g. of factsigner) */\n\n        uint8 marketInterval;\n        uint8 transactionFee0; /* fee in 1/100 per cent (payed by orderTaker) */\n        uint8 transactionFee1; /* fee in 1/100 per cent (payed by orderTaker) */\n        uint8 transactionFeeSigner; /* fee in 1/100 per cent (payed by orderTaker) */\n        address feeTaker0;\n        address feeTaker1;\n        int128[] strikes;\n    }\n\n    struct MarketState {\n        /* winningOptionID is only valid if settled == true */\n        uint128 fee; // total payed fee (for all fee takers)\n        uint16 winningOptionID;\n        bool settled;\n    }\n\n    struct MarketData {\n        MarketBaseData marketBaseData;\n        MarketState marketState;\n        bytes32 marketHash;\n        UserState userState;\n        bool testMarket; // only used by MarketLister\n    }\n\n\n// TODO remove long term? (and add 2-year?)\n// TODO remove uint8() conversion\n// TODO time offset between marketsContract and marketListerContract?\n\n    /* until const arrays are supported in solidity we use our custom function */\n    uint256 constant DIVIDER_ENTRY_BYTES = 6;\n    bytes constant DIVIDER_TABLE = \"\\\n\\x00\\x00\\x00\\x00\\x00\\x00\\\n\\x00\\x00\\x00\\xfa\\x7d\\x00\\\n\\x00\\x00\\x00\\x3b\\x53\\x80\\\n\\x00\\x00\\x00\\x0a\\x8c\\x00\\\n\\x00\\x00\\x00\\x01\\xfa\\x40\\\n\\x00\\x00\\x00\\x00\\x1c\\x20\\\n\\x00\\x00\\x00\\x00\\x00\\x00\\\n\";\n\n    function getDivider(\n        uint256 calculatedMarketInterval\n    )\n        internal\n        pure\n        returns (uint48)\n    {\n        bytes memory table = DIVIDER_TABLE;\n        uint offset = (calculatedMarketInterval + 1) * DIVIDER_ENTRY_BYTES;\n        uint48 value;\n        assembly {\n            value := mload(add(table, offset))\n        }\n\n        return value;\n    }\n\n\n    // TODO this is only 'view' and not internal because of block.timestamp - maybe change that\n    function calcMarketInterval (\n        uint40 expirationDatetime\n    )\n        internal\n        view\n        returns (uint8 interval)\n    {\n        uint8 marketInterval;\n        uint256 secondsUntilExpiration = uint256(expirationDatetime).sub(uint256(block.timestamp));\n        // TODO > or >= ?\n        require(secondsUntilExpiration < 730 * 24 * 60 * 60, \"too far in the future\");\n        if (secondsUntilExpiration > 45 * 24 * 60 * 60) // > 45 days\n            marketInterval = uint8(FactsignerDefines.MarketInterval.YEARLY);\n        else if (secondsUntilExpiration > 8 * 24 * 60 * 60) // > 8 days\n            marketInterval = uint8(FactsignerDefines.MarketInterval.MONTHLY);\n        else if (secondsUntilExpiration > 36 * 60 * 60) // > 36 hours\n            marketInterval = uint8(FactsignerDefines.MarketInterval.WEEKLY);\n        else if (secondsUntilExpiration > 2 * 60 * 60) // > 2 hours\n            marketInterval = uint8(FactsignerDefines.MarketInterval.DAILY);\n        else if (secondsUntilExpiration > 15 * 60) // > 15 min\n            marketInterval = uint8(FactsignerDefines.MarketInterval.HOURLY);\n        else\n            marketInterval = uint8(FactsignerDefines.MarketInterval.SHORT_TERM);\n\n        return marketInterval;\n    }\n\n    function calcFactHash (\n        DigiOptionsLib.MarketBaseData memory marketBaseData\n    )\n        internal\n        pure // this should be external (see https://github.com/ethereum/solidity/issues/5479)\n        returns (bytes32 factHash)\n    {\n        bytes memory data;\n        data = abi.encodePacked(\n            keccak256(abi.encodePacked(marketBaseData.underlyingString)), /* 'name' utf8 encoded */\n            marketBaseData.expirationDatetime, /* 'settlement' unix epoch seconds UTC */\n            marketBaseData.objectionPeriod, /* e.g. 3600 seconds */\n            marketBaseData.config,\n            marketBaseData.marketCategory,\n\n            marketBaseData.baseUnitExp, /* e.g. 18 -> baseUnit = 10**18 = 1000000000000000000 */\n            marketBaseData.ndigit /* 'ndigit' number of digits (may be negative) */\n        );\n        // if this is a named market we simply use strikes as factsigner's namedRanges\n        if ((marketBaseData.config & uint8(FactsignerDefines.ConfigMask.ConfigMarketTypeIsStrikedMask) == 0)) {\n            data = abi.encodePacked(\n                data,\n                marketBaseData.strikes\n            );\n        }\n        return keccak256(data);\n    }\n\n    function calcMarketHash (\n        DigiOptionsLib.MarketBaseData memory marketBaseData\n    )\n        internal\n        pure\n        returns (bytes32 marketHash)\n    {\n        bytes memory data;\n        data = abi.encodePacked(\n            // TODO from facthash?\n            keccak256(abi.encodePacked(marketBaseData.underlyingString)), /* 'name' utf8 encoded */\n            marketBaseData.expirationDatetime, /* 'settlement' unix epoch seconds UTC */\n            marketBaseData.objectionPeriod, /* e.g. 3600 seconds */\n            marketBaseData.config,\n            marketBaseData.marketCategory,\n\n            marketBaseData.baseUnitExp, /* e.g. 18 -> baseUnit = 10**18 = 1000000000000000000 */\n            marketBaseData.ndigit, /* 'ndigit' number of digits (may be negative) */\n\n            marketBaseData.marketInterval,\n            marketBaseData.feeTaker0,\n            marketBaseData.feeTaker1,\n            marketBaseData.signerAddr /* address used to check the signed result (e.g. of factsigner) */\n        );\n        data = abi.encodePacked(\n            data,\n            marketBaseData.transactionFee0,\n            marketBaseData.transactionFee1,\n            marketBaseData.transactionFeeSigner,\n            marketBaseData.strikes\n        );\n        return keccak256(data);\n    }\n\n    function calcBaseMarketHash (\n        MarketBaseData memory marketBaseData\n    )\n        internal\n        pure\n        returns (bytes32 baseMarketHash)\n    {\n        /* baseMarketHash is similar to marketHash but does not contain all elements. It's basically a factHash with added marketInterval */\n        bytes memory data;\n        data = abi.encodePacked(\n            keccak256(abi.encodePacked(marketBaseData.underlyingString)), /* 'name' utf8 encoded */\n            marketBaseData.expirationDatetime, /* 'settlement' unix epoch seconds UTC */\n            marketBaseData.objectionPeriod, /* e.g. 3600 seconds */\n            marketBaseData.config,\n            marketBaseData.marketCategory,\n\n            marketBaseData.baseUnitExp, /* e.g. 18 -> baseUnit = 10**18 = 1000000000000000000 */\n            marketBaseData.ndigit, /* 'ndigit' number of digits (may be negative) */\n\n            marketBaseData.marketInterval,\n\n            marketBaseData.signerAddr\n        );\n        // if this is a named market we simply use strikes as factsigner's namedRanges\n        if ((marketBaseData.config & uint8(FactsignerDefines.ConfigMask.ConfigMarketTypeIsStrikedMask) == 0)) {\n            data = abi.encodePacked(\n                data,\n                marketBaseData.strikes\n            );\n        }\n        return keccak256(data);\n\n    }\n\n\n    bytes constant OFFER_PREFIX = \"\\x19Ethereum Signed Message:\\n32\"; // TODO\n    function verifyOffer(\n        bytes32 message,\n        Signature memory signature\n    )\n        internal\n        pure\n        returns (address addr)\n    {\n        bytes32 prefixedHash = keccak256(\n            abi.encodePacked(\n                OFFER_PREFIX,\n                message\n            )\n        );\n        address signer = ecrecover(\n            prefixedHash,\n            signature.v,\n            signature.r,\n            signature.s\n        );\n        return signer;\n    }\n}\n",
		"factsigner/contracts/FactsignerDefines.sol": "/*\n Contract defines for https://www.factsigner.com\n\n Public repository:\n https://github.com/berlincode/factsigner\n\n Version 7.0.0\n\n SPDX-License-Identifier: MIT\n\n MIT License\n\n Copyright (c) factsigner.com (https://www.factsigner.com)\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all\n copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.\n\n*/\n\npragma solidity >=0.7.0;\n\nlibrary FactsignerDefines\n{\n    // TODO we use a enum here as a hack until\n    // https://github.com/ethereum/solidity/issues/1290 is solved\n    enum ConfigMask {\n        ConfigMaskDummy0,\n        ConfigMarketTypeIsStrikedMask, // = 1\n        ConfigMaskDummy2,\n        ConfigMaskDummy3,\n        ConfigIntervalTypeIsUsedMask // = 4\n    }\n\n    enum SettlementType {\n        FINAL, // = 0\n        PRELIMINARY_FIRST // = 1\n        //PRELIMINARY_MAX // = 65535\n    }\n\n    enum MarketInterval {\n        NONE, // = 0\n        // the following constants are just proposed assignments\n        YEARLY, // = 1\n        QUATERLY, // 2\n        MONTHLY, // = 3\n        WEEKLY, // = 4\n        DAILY, // = 5\n        HOURLY, // = 6\n        SHORT_TERM // = 7\n    }\n\n}\n",
		"@openzeppelin/contracts/utils/math/SafeMath.sol": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
	},
	"compiler": {
		"name": "solc",
		"version": "0.8.12+commit.f00d7308",
		"settings": {
			"remappings": [
				"factsigner=/home/ulf/digioptions/digioptions-contracts.js/node_modules/factsigner",
				"@openzeppelin/contracts=/home/ulf/digioptions/digioptions-contracts.js/node_modules/@openzeppelin/contracts"
			],
			"optimizer": {
				"enabled": true,
				"runs": 20000,
				"details": {
					"yul": true,
					"deduplicate": true,
					"cse": true,
					"constantOptimizer": true
				}
			},
			"outputSelection": {
				"*": {
					"*": [
						"abi",
						"evm.bytecode.object",
						"evm.bytecode.sourceMap",
						"evm.deployedBytecode.object",
						"evm.deployedBytecode.sourceMap"
					]
				}
			}
		}
	},
	"chains": {}
}