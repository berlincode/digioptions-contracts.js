{"language":"Solidity","settings":{"optimizer":{"enabled":true},"outputSelection":{"*":{"*":["metadata","evm.bytecode","abi"]}}},"sources":{"contracts/DigiOptionsMarkets.sol":{"content":"/*\n User Driven Option Markets Contract used by https://www.digioptions.com\n\n Copyright (c) [www.digioptions.com](https://www.digioptions.com)\n\n Designed to work with signatures from [www.factsigner.com](https://www.factsigner.com)\n\n Public repository:\n https://github.com/berlincode/digioptions-contracts.js\n\n elastic.code@gmail.com\n mail@digioptions.com\n\n*/\n\npragma solidity 0.5.8;\npragma experimental ABIEncoderV2;\n\nimport \"./DigiOptionsBaseInterface.sol\";\nimport \"./SafeMath.sol\";\nimport \"./SafeCast.sol\";\n\n\ncontract DigiOptionsMarkets is DigiOptionsBaseInterface {\n    using SafeCast for int;\n    using SafeCast for uint;\n    using SafeMath for uint256;\n    using SafeMath for int256;\n\n    uint256 public version = (\n        (0 << 32) + /* major */\n        (46 << 16) + /* minor */\n        0 /* bugfix */\n    );\n\n    //each nanoOption is worth 1000000000 wei in case of win,\n    // so one whole option is worth 1 ether in case of win\n    int256 constant public PAYOUT_PER_NANOOPTION = 1000000000;\n\n    struct UserData { // TODO rename\n        UserState state; // just to remember which user was already added\n        mapping(uint16 => int256) positions;\n    }\n\n    /* we use a simple linked list to sort contracts by expirationDatetime date */\n    struct Market {\n        bytes32 marketHashPrevious;\n\n        Data data;\n        MarketBaseData marketBaseData;\n        mapping(address => UserData) userData;\n\n        /* for settlement calculation we need a list of all users */\n        address[] users;\n        uint256 fee;\n    }\n\n    struct OrderOffer {\n        bytes32 marketHash;\n        uint16 optionID;\n        bool buy; // does the offer owner want to buy or sell options\n        uint256 pricePerOption;\n        uint256 size;\n        uint256 offerID;\n        uint256 blockExpires;\n        address offerOwner;\n    }\n\n    struct OrderOfferSigned {\n        OrderOffer orderOffer;\n        Signature signature;\n    }\n\n    /* variables */\n    mapping(address => uint256) internal liquidityUser;\n    Market internal head; /* we use only head.marketHashPrevious */\n    mapping(bytes32 => Market) internal markets;\n\n    mapping(bytes32 => uint256) internal offersAccepted; // remember how many options from an offer are already traded\n    mapping(address => bytes32[]) internal userMarkets; // keep track which markets a user is invested\n    mapping(address => uint32) internal userMarketsIdx;\n\n    event MarketCreate(bytes32 marketHash, uint64 indexed expirationDatetime, bytes32 indexed underlying, uint8 indexed typeDuration);\n    event MarketSettlement(bytes32 marketHash);\n    // this may result in liquidity change\n    event LiquidityAddWithdraw(address indexed addr, uint256 datetime, int256 amount);\n    event PositionChange(\n        // TODO optimize order for storage density?\n        address indexed buyer,\n        address indexed seller,\n        bytes32 indexed marketHash,\n        uint256 datetime, // TODO we might remove this and use info from block\n        uint16 optionID,\n        uint256 pricePerOption,\n        uint256 size,\n        bytes32 offerHash\n    );\n\n    /* This is the constructor */\n    //constructor () public {\n    //}\n\n    // default fallback\n    function() external payable {\n        liquidityAdd();\n    }\n\n    function getContractInfo (\n    ) external\n    returns (\n        ContractType contractType,\n        uint256 versionMarketLister,\n        uint256 versionMarkets,\n        address digiOptionsMarketsAddr\n    )\n    {\n        return (\n            ContractType.CONTRACT_DIGIOPTIONSMARKETS, // == 1\n            0,\n            version,\n            address(this)\n        );\n    }\n\n    function liquidityWithdraw (uint256 amount) external {\n        require (amount <= liquidityUser[msg.sender], \"Not enough liquidity.\");\n        /* Remember to reduce the liquidity BEFORE */\n        /* sending to prevent re-entrancy attacks */\n        liquidityUser[msg.sender] = liquidityUser[msg.sender].sub(amount);\n        msg.sender.transfer(amount);\n        emit LiquidityAddWithdraw(msg.sender, block.timestamp, int256(-amount));\n    }\n\n    function getMarketDataList (\n        bool filterTestMarkets, // default: true // if true all test markets are filtered out\n        bool filterNoTradedMarkets, // default: false // filter out all markets the the uses (msg.sender) has not traded\n        uint64 expirationDatetime,\n        uint16 len,\n        bytes32[] calldata marketHashLast // if list is empty we start at head - otherwise we continue to list after marketHashLast[0]\n    )\n        external\n        view\n        returns (MarketData[] memory marketList)\n    {\n        Market memory market;\n        marketList = new MarketData[](len);\n        uint256 idx = 0;\n\n        if (marketHashLast.length == 0) {\n            market = head;\n        } else {\n            market = markets[marketHashLast[0]];\n        }\n\n        MarketData memory marketDataPrev = getMarketData(market.marketHashPrevious);\n\n        while (\n            (idx < len) &&\n            (marketDataPrev.marketBaseData.expirationDatetime > 0) &&\n            (marketDataPrev.marketBaseData.expirationDatetime >= expirationDatetime)\n        ) {\n            if (!\n                (\n                    //(filterTestMarkets && marketDataPrev.testMarket) ||\n                    (filterNoTradedMarkets && (marketDataPrev.userState != UserState.USER_NONE))\n                )) {\n                marketList[idx] = marketDataPrev;\n                idx++;\n            }\n            market = markets[market.marketHashPrevious];\n            marketDataPrev = getMarketData(market.marketHashPrevious);\n        }\n        return marketList;\n    }\n\n    function getLiquidityAndPositions (bytes32 marketHash)\n        external\n        view\n        returns (uint256 liquidity, int256[] memory positions, UserState userState)\n    {\n        // return user's total contract liquidity and positions for selected market\n        int256[] memory positionsOptionID = new int256[](markets[marketHash].marketBaseData.strikes.length + 1);\n        for (uint16 optionID = 0; optionID <= markets[marketHash].marketBaseData.strikes.length; optionID++) {\n            positionsOptionID[optionID] = markets[marketHash].userData[msg.sender].positions[optionID];\n        }\n        return (liquidityUser[msg.sender], positionsOptionID, markets[marketHash].userData[msg.sender].state);\n    }\n\n    function getNumUsersToPayout(\n        bytes32 marketHash\n    )\n        external\n        view\n        returns (uint256 numUsersToPayout)\n    {\n        return markets[marketHash].users.length;\n    }\n\n    function calcTypeDuration (\n        uint64 expirationDatetime\n    ) public view\n    returns (uint8 factHash)\n    {\n        uint8 typeDuration = 5;\n        uint256 secondsUntilExpiration = uint256(expirationDatetime).sub(uint256(block.timestamp));\n        if (secondsUntilExpiration > 3888000) // > 45 days\n            typeDuration = 0;\n        else if (secondsUntilExpiration > 8 * 24 * 60 * 60) // > 9 days\n            typeDuration = 1;\n        else if (secondsUntilExpiration > 36 * 60 * 60) // > 36 hours\n            typeDuration = 2;\n        else if (secondsUntilExpiration > 2 * 60 * 60) // > 2 hours\n            typeDuration = 3;\n        else if (secondsUntilExpiration > 15 * 60) // > 15 min\n            typeDuration = 4;\n\n        return typeDuration;\n    }\n\n    function liquidityAdd () public payable {\n        if (msg.value > 0) {\n            liquidityUser[msg.sender] = liquidityUser[msg.sender].add(msg.value);\n            emit LiquidityAddWithdraw(msg.sender, block.timestamp, int256(msg.value));\n        }\n    }\n\n    function createMarket (\n        MarketBaseData memory marketBaseData,\n        bool testMarket,\n        Signature memory signature\n    ) public // this should be external (see https://github.com/ethereum/solidity/issues/5479)\n    returns (bytes32 _marketHash)\n    {\n        assert(marketBaseData.expirationDatetime != 0);\n\n        require(\n            verify(\n                calcFactHash(marketBaseData),\n                signature\n            ) == marketBaseData.signerAddr,\n            \"Signature invalid.\"\n        );\n\n        assert(marketBaseData.typeDuration == calcTypeDuration(marketBaseData.expirationDatetime));\n\n        bytes32 marketHash = keccak256(\n            abi.encodePacked(\n                marketBaseData.baseUnitExp, /* e.g. 18 -> baseUnit = 10**18 = 1000000000000000000 */\n                marketBaseData.underlying, /* 'name' ascii encoded string as bytes32 */\n                marketBaseData.ndigit, /* 'ndigit' number of digits (may be negative) */\n                marketBaseData.objectionPeriod, /* e.g. 3600 seconds */\n                marketBaseData.expirationDatetime, /* 'settlement' unix epoch seconds UTC */\n\n                marketBaseData.typeDuration,\n                marketBaseData.feeTaker0,\n                marketBaseData.feeTaker1,\n                marketBaseData.signerAddr, /* address used to check the signed result (e.g. of factsigner) */\n\n                marketBaseData.transactionFee0, /* fee in wei for every ether of value (payed by orderTaker) */\n                marketBaseData.transactionFee1, /* fee in wei for every ether of value (payed by orderTaker) */\n                marketBaseData.strikes\n            )\n        );\n\n        /* Check that the market does not already exists */\n        if (markets[marketHash].marketBaseData.expirationDatetime != 0)\n            return marketHash;\n\n        assert(marketBaseData.baseUnitExp == 18); // TODO remove this in the future\n\n        /* check that we have at least one strike */\n        assert(marketBaseData.strikes.length > 0);\n        assert(marketBaseData.strikes.length <= 32765); // our first optionID is 0\n        assert((uint256(marketBaseData.transactionFee0)).add(uint256(marketBaseData.transactionFee1)) <= 50 finney); // max 5%\n\n        /* check strikes are ordered */\n        uint16 cnt;\n        for (cnt = 1; cnt < marketBaseData.strikes.length; cnt++) {\n            assert(marketBaseData.strikes[cnt-1] < marketBaseData.strikes[cnt]);\n        }\n\n        /* check that the final settlement precision high enough for the supplied strikes */\n        assert(int16(marketBaseData.baseUnitExp) >= marketBaseData.ndigit);\n        for (cnt = 0; cnt < marketBaseData.strikes.length; cnt++) {\n            assert((marketBaseData.strikes[cnt] % int256(10**uint256((int256(marketBaseData.baseUnitExp)-marketBaseData.ndigit)))) == 0);\n        }\n\n        /* find the right place to insert */\n        Market storage market = head;\n        while (markets[market.marketHashPrevious].marketBaseData.expirationDatetime > marketBaseData.expirationDatetime) {\n            market = markets[market.marketHashPrevious];\n        }\n\n        /* using memory for struct before commiting to storage */\n        Market memory newMarket;\n        newMarket.marketHashPrevious = market.marketHashPrevious;\n\n        newMarket.data = Data(\n            {\n            // winningOptionID is only valid if settled == true\n            winningOptionID: 0,\n            settled: false\n            }\n        );\n\n        newMarket.marketBaseData = marketBaseData;\n\n        /* insert */\n        markets[marketHash] = newMarket;\n        market.marketHashPrevious = marketHash;\n\n        emit MarketCreate(\n            marketHash,\n            marketBaseData.expirationDatetime,\n            marketBaseData.underlying,\n            marketBaseData.typeDuration\n        );\n        return marketHash;\n    }\n\n    /* returns all relevant market data - if marketHash does not exist marketBaseData.expirationDatetime is 0*/\n    function getMarketData (bytes32 marketHash)\n        public\n        view\n        returns (MarketData memory marketData)\n    {\n        Market storage market = markets[marketHash];\n        return MarketData({\n            marketBaseData: market.marketBaseData,\n            data: market.data,\n            marketHash: marketHash,\n            userState: market.userData[msg.sender].state,\n            testMarket: false // only used by MarketLister\n        });\n    }\n\n    function calcFactHash (\n        MarketBaseData memory marketBaseData\n    ) public pure // this should be external (see https://github.com/ethereum/solidity/issues/5479)\n    returns (bytes32 factHash)\n    {\n        return keccak256(\n            abi.encodePacked(\n                marketBaseData.baseUnitExp, /* e.g. 18 -> baseUnit = 10**18 = 1000000000000000000 */\n                marketBaseData.underlying, /* 'name' ascii encoded string as bytes32 */\n                marketBaseData.ndigit, /* 'ndigit' number of digits (may be negative) */\n                marketBaseData.objectionPeriod, /* e.g. 3600 seconds */\n                marketBaseData.expirationDatetime /* 'settlement' unix epoch seconds UTC */\n            )\n        );\n    }\n\n    function settlement (\n        bytes32 marketHash, /* market to settle */\n        Signature memory signature,\n        int256 value,\n        uint256 maxNumUsersToPayout\n    ) public // this should be external (see https://github.com/ethereum/solidity/issues/5479)\n    {\n        require(markets[marketHash].data.settled == false, \"Market already settled.\");\n        Market storage market = markets[marketHash];\n\n        /* anybody with access to the signed value (from signerAddr) can settle the market */\n\n        require(\n            verify(\n                keccak256(\n                    abi.encodePacked(\n                        calcFactHash(market.marketBaseData),\n                        value,\n                        uint16(0) // signature type: signature_final == 0\n                    )\n                ),\n                signature\n            ) == markets[marketHash].marketBaseData.signerAddr,\n            \"Signature invalid.\"\n        );\n\n        uint16 winningOptionID = uint16(market.marketBaseData.strikes.length);\n        for (uint16 cnt = 0; cnt < market.marketBaseData.strikes.length; cnt++) {\n            if (value < market.marketBaseData.strikes[cnt]) {\n                winningOptionID = cnt;\n                break;\n            }\n        }\n        markets[marketHash].data.winningOptionID = winningOptionID;\n        markets[marketHash].data.settled = true;\n\n        if ((markets[marketHash].users.length == 0)) {\n            // emit event once\n            emit MarketSettlement(marketHash);\n        } else {\n            // TODO remove this function and call settlement separately?\n            settlementPayOut(\n                marketHash,\n                maxNumUsersToPayout\n            );\n\t}\n    }\n\n    function settlementPayOut(\n        bytes32 marketHash,\n        uint256 maxNumUsersToPayout\n    ) public // TODO make external (later)\n    {\n        Market storage market = markets[marketHash];\n        uint16 winningOptionID = markets[marketHash].data.winningOptionID;\n        require(markets[marketHash].data.settled == true, \"Market not yet settled.\");\n\n        uint256 idx;\n        for (idx = 0; idx < maxNumUsersToPayout; idx++) {\n            if (markets[marketHash].users.length == 0)\n                break;\n\n            address user = market.users[market.users.length - 1];\n            market.users.length -= 1;\n\n            int256 minPosition;\n            int256 minPositionAfterTrade;\n            (minPosition, minPositionAfterTrade) = getMinPosition(\n                marketHash,\n                user,\n                0,\n                0\n            );\n\n            int256 result = market.userData[user].positions[winningOptionID].sub(minPosition);\n\n            market.userData[user].state = UserState.USER_PAYED_OUT;\n            liquidityUser[user] = liquidityUser[user].add(result.mul(PAYOUT_PER_NANOOPTION).castToUint());\n        }\n        if ((idx > 0) && (markets[marketHash].users.length == 0)) {\n            // TODO split fee and add fee to feeTaker1, too\n            liquidityUser[market.marketBaseData.feeTaker0] = liquidityUser[market.marketBaseData.feeTaker0].add(market.fee);\n            // emit event once if all users have been payed out\n            emit MarketSettlement(marketHash);\n        }\n    }\n\n    function orderExecuteTest (\n        OrderOfferSigned memory orderOfferSigned,\n        uint256 sizeAccept // TODO rename to sizeAcceptMax?\n    ) public view returns (\n        uint256 sizeAcceptPossible,\n        bytes32 offerHash,\n        int256 liquidityOfferOwner, // only valid if sizeAcceptPossible > 0\n        int256 liquidityOfferTaker, // only valid if sizeAcceptPossible > 0\n        uint256 transactionFeeAmount // only valid if sizeAcceptPossible > 0\n    )\n    {\n        OrderOffer memory orderOffer = orderOfferSigned.orderOffer;\n        bytes32 offerHash_ = keccak256(\n            abi.encodePacked(\n                address(this), // this checks that the signature is valid only for this contract\n                orderOffer.marketHash,\n                orderOffer.optionID,\n                orderOffer.buy,\n                orderOffer.pricePerOption,\n                orderOffer.size,\n                orderOffer.offerID,\n                orderOffer.blockExpires,\n                orderOffer.offerOwner\n            )\n        );\n        if (offersAccepted[offerHash_].add(sizeAccept) > orderOffer.size)\n            sizeAccept = orderOffer.size.sub(offersAccepted[offerHash_]);\n\n        uint256 value = sizeAccept.mul(orderOffer.pricePerOption);\n        uint256 transactionFeeAmount_ = value.mul(\n            uint256(markets[orderOffer.marketHash].marketBaseData.transactionFee0).add(uint256(markets[orderOffer.marketHash].marketBaseData.transactionFee1))\n        ).div(1 ether);\n\n        liquidityOfferOwner = getLiquidityAfterTrade(\n            orderOffer.buy,\n            orderOffer,\n            orderOffer.offerOwner,\n            sizeAccept,\n            value\n        );\n        liquidityOfferTaker = getLiquidityAfterTrade(\n            !orderOffer.buy,\n            orderOffer,\n            msg.sender,\n            sizeAccept,\n            value\n        ).sub(transactionFeeAmount_.castToInt());\n\n        if (!(\n                (verify(\n                    offerHash_,\n                    orderOfferSigned.signature\n                ) == orderOffer.offerOwner) &&\n                (orderOffer.optionID <= markets[orderOffer.marketHash].marketBaseData.strikes.length) &&\n                (block.number <= orderOffer.blockExpires) &&\n                (block.number.add(12) >= orderOffer.blockExpires) &&\n                // offerTaker and offerOwner must not be the same (because liquidity is calculated seperately)\n                (orderOffer.offerOwner != msg.sender) &&\n                (liquidityOfferOwner >= int256(0)) &&\n                (liquidityOfferTaker >= int256(0))\n            )) {\n            sizeAccept = 0;\n        }\n        return (\n            sizeAccept,\n            offerHash_,\n            liquidityOfferOwner, // only valid if sizeAcceptPossible > 0\n            liquidityOfferTaker, // only valid if sizeAcceptPossible > 0\n            transactionFeeAmount_ // only valid if sizeAcceptPossible > 0\n        );\n    }\n\n    // OrderOfferSigned array should contain only sell orders or only buys orders for the same optionID an marketHash (not mixed)\n    function orderExecute (\n        OrderOfferSigned[] memory orderOfferSignedList,\n        uint256 sizeAcceptMax /* maximum for all supplied orderOfferSigned structs */\n    ) public // this should be external (see https://github.com/ethereum/solidity/issues/5479)\n    {\n        uint256 sizeAcceptMax_ = sizeAcceptMax;\n\n        for (uint256 orderOfferIdx=0; orderOfferIdx < orderOfferSignedList.length; orderOfferIdx++) {\n            OrderOffer memory orderOffer = orderOfferSignedList[orderOfferIdx].orderOffer;\n            bytes32 offerHash;\n            uint256 sizeAcceptPossible;\n\n            address buyer; // buys options / money giver\n            address seller; // sells options / money getter\n            if (orderOffer.buy) {\n                buyer = orderOffer.offerOwner;\n                seller = msg.sender;\n            } else {\n                buyer = msg.sender;\n                seller = orderOffer.offerOwner;\n            }\n\n            int256 liquidityOfferOwner; // only valid if sizeAcceptPossible > 0\n            int256 liquidityOfferTaker; // only valid if sizeAcceptPossible > 0\n            uint256 transactionFeeAmount; // only valid if sizeAcceptPossible > 0\n            (\n                sizeAcceptPossible,\n                offerHash,\n                liquidityOfferOwner, // only valid if sizeAcceptPossible > 0\n                liquidityOfferTaker, // only valid if sizeAcceptPossible > 0\n                transactionFeeAmount // only valid if sizeAcceptPossible > 0\n            ) = orderExecuteTest (\n                orderOfferSignedList[orderOfferIdx],\n                sizeAcceptMax_\n            );\n            if (sizeAcceptPossible != 0) {\n\n                liquidityUser[orderOffer.offerOwner] = liquidityOfferOwner.castToUint();\n                liquidityUser[msg.sender] = liquidityOfferTaker.castToUint();\n                markets[orderOffer.marketHash].fee = markets[orderOffer.marketHash].fee.add(transactionFeeAmount); // TODO\n\n                // update positions\n                markets[orderOffer.marketHash].userData[buyer].positions[orderOffer.optionID] =\n                    markets[orderOffer.marketHash].userData[buyer].positions[orderOffer.optionID].add(int256(sizeAcceptPossible));\n                markets[orderOffer.marketHash].userData[seller].positions[orderOffer.optionID] =\n                    markets[orderOffer.marketHash].userData[seller].positions[orderOffer.optionID].sub(int256(sizeAcceptPossible));\n\n                // remember that (some amount of) the offers is taken\n                offersAccepted[offerHash] = offersAccepted[offerHash].add(sizeAcceptPossible);\n\n                // remember user for final settlement calculation\n                if (markets[orderOffer.marketHash].userData[msg.sender].state== UserState.USER_NONE) {\n                    markets[orderOffer.marketHash].userData[msg.sender].state = UserState.USER_EXISTS;\n                    markets[orderOffer.marketHash].users.push(msg.sender);\n                    userMarkets[msg.sender].push(orderOffer.marketHash);\n                }\n                if (markets[orderOffer.marketHash].userData[orderOffer.offerOwner].state == UserState.USER_NONE) {\n                    markets[orderOffer.marketHash].userData[orderOffer.offerOwner].state = UserState.USER_EXISTS;\n                    markets[orderOffer.marketHash].users.push(orderOffer.offerOwner);\n                    userMarkets[orderOffer.offerOwner].push(orderOffer.marketHash);\n                }\n\n                emit PositionChange(\n                    buyer,\n                    seller,\n                    orderOffer.marketHash,\n                    block.timestamp,\n                    orderOffer.optionID,\n                    orderOffer.pricePerOption,\n                    sizeAcceptPossible,\n                    offerHash\n                );\n\n                sizeAcceptMax_ = sizeAcceptMax_.sub(sizeAcceptPossible);\n            }\n        }\n    }\n\n    function getLiquidityAfterTrade(\n        bool isBuyer,\n        OrderOffer memory orderOffer,\n        address userAddr,\n        uint256 sizeAccept,\n        uint256 value\n    ) internal view\n        returns (\n        int256 _liquidity\n    )\n    {\n        int256 liquidity = liquidityUser[userAddr].castToInt();\n        int256 sizeAccept_;\n\n        if (! isBuyer) {\n            liquidity = liquidity.add(value.castToInt()); // seller gets money\n            sizeAccept_ = int256(0).sub(sizeAccept.castToInt());\n        } else {\n            liquidity = liquidity.sub(value.castToInt()); // buyer pays money\n            sizeAccept_ = sizeAccept.castToInt();\n        }\n\n        int256 minPositionBeforeTrade;\n        int256 minPositionAfterTrade;\n        (minPositionBeforeTrade, minPositionAfterTrade) = getMinPosition(\n            orderOffer.marketHash,\n            userAddr,\n            orderOffer.optionID,\n            sizeAccept_\n        );\n\n        liquidity = liquidity.add((minPositionAfterTrade.sub(minPositionBeforeTrade)).mul(PAYOUT_PER_NANOOPTION));\n\n        return liquidity;\n    }\n\n    function getMinPosition (\n        bytes32 marketHash,\n        address userAddr,\n        /* optional to calc the minimal position after a change */\n        uint16 optionID,\n        int256 positionChange\n    ) internal view returns (int256 minPositionBeforeTrade_, int256 minPositionAfterTrade_)\n    {\n        int256 minPositionBeforeTrade = int256(~((uint256(1) << 255))); // INT256_MAX\n        int256 minPositionAfterTrade = int256(~((uint256(1) << 255))); // INT256_MAX\n\n        for (uint16 s = 0; s <= markets[marketHash].marketBaseData.strikes.length; s++) {\n\n            int256 position = markets[marketHash].userData[userAddr].positions[s];\n            if (position < minPositionBeforeTrade)\n                minPositionBeforeTrade = position;\n\n            if (s == optionID)\n                position = position.add(positionChange);\n\n            if (position < minPositionAfterTrade)\n                minPositionAfterTrade = position;\n        }\n        return (minPositionBeforeTrade, minPositionAfterTrade);\n    }\n\n    /* internal functions */\n    function verify(\n        bytes32 message,\n        Signature memory signature\n    ) internal pure returns (address addr)\n    {\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n        bytes32 prefixedHash = keccak256(\n            abi.encodePacked(\n                prefix,\n                message\n            )\n        );\n        address signer = ecrecover(\n            prefixedHash,\n            signature.v,\n            signature.r,\n            signature.s\n        );\n        return signer;\n    }\n\n}\n"},"contracts/DigiOptionsMarketLister.sol":{"content":"/*\n User Driven Option Markets Contract used by https://www.digioptions.com\n\n Copyright (c) [www.digioptions.com](https://www.digioptions.com)\n\n Designed to work with signatures from [www.factsigner.com](https://www.factsigner.com)\n\n Public repository:\n https://github.com/berlincode/digioptions-contracts.js\n\n elastic.code@gmail.com\n mail@digioptions.com\n\n*/\n\npragma solidity 0.5.8;\npragma experimental ABIEncoderV2;\n\nimport \"./DigiOptionsBaseInterface.sol\";\nimport \"./DigiOptionsMarkets.sol\";\nimport \"./SafeMath.sol\";\n\n\ncontract DigioptionsMarketLister is DigiOptionsBaseInterface {\n    using SafeMath for uint256;\n    using SafeMath for int256;\n\n    uint256 public version = (\n        (0 << 32) + /* major */\n        (46 << 16) + /* minor */\n        0 /* bugfix */\n    );\n\n    /* constants which are set during construction */\n    address public owner;\n    DigiOptionsMarkets public digiOptionsMarkets;\n\n    /* control varialbles */\n    uint16 public openDelaySeconds = 100;\n    uint64 public transactionFeeMax = 10 finney; // 0.01 = 1.0%\n\n    /* we use a simple linked list to sort contracts by expirationDatetime date */\n    struct Market {\n        bytes32 baseMarketHashPrevious;\n        bytes32 marketHash;\n        uint64 expirationDatetime; /* used for sorting contracts */ // TODO we may use expirationDatetime from main markets contract\n        bool testMarket;\n    }\n\n    /* variables */\n    Market internal head; /* we use only head.baseMarketHashPrevious */\n    mapping(bytes32 => Market) internal markets;\n\n    struct MarketBest {\n        bytes32 marketHash;\n        uint64 transactionFee0;\n        uint40 time;\n        uint16 openDelaySeconds;\n    }\n    mapping(bytes32 => MarketBest) internal marketsBest;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call this function.\");\n        _;\n    }\n\n    event MarketCreateLister(\n        bytes32 baseMarketHash,\n        uint64 indexed expirationDatetime,\n        bytes32 indexed underlying,\n        uint8 indexed typeDuration,\n        uint16 openDelaySeconds\n    );\n\n    constructor (DigiOptionsMarkets addr) public {\n        owner = msg.sender;\n        digiOptionsMarkets = addr;\n    }\n\n    // default fallback\n    function() external payable {\n        revert();\n    }\n\n    function getContractInfo (\n    ) external\n    returns (\n        ContractType contractType,\n        uint256 versionMarketLister,\n        uint256 versionMarkets,\n        address digiOptionsMarketsAddr\n    )\n    {\n        return (\n            ContractType.CONTRACT_DIGIOPTIONSMARKETLISTER, // == 2\n            version,\n            digiOptionsMarkets.version(), // versionMarkets\n            address(digiOptionsMarkets)\n        );\n    }\n\n    function getMarketDataList (\n        bool filterTestMarkets, // default: true // if true all test markets are filtered out\n        bool filterNoTradedMarkets, // default: false // filter out all markets the the uses (msg.sender) has not traded\n        uint64 expirationDatetime,\n        uint16 len,\n        bytes32[] calldata marketHashLast // if list is empty we start at head - otherwise we continue to list after marketHashLast[0]\n    )\n        external\n        view\n        returns (DigiOptionsMarkets.MarketData[] memory marketList)\n    {\n        Market memory market;\n        marketList = new MarketData[](len);\n        uint256 idx = 0;\n\n        if (marketHashLast.length == 0) {\n            market = head;\n        } else {\n            market = markets[calcBaseMarketHash(digiOptionsMarkets.getMarketData(marketHashLast[0]))];\n        }\n\n        MarketData memory marketDataPrev = digiOptionsMarkets.getMarketData(markets[market.baseMarketHashPrevious].marketHash);\n\n        while (\n            (idx < len) &&\n            (marketDataPrev.marketBaseData.expirationDatetime > 0) &&\n            (marketDataPrev.marketBaseData.expirationDatetime >= expirationDatetime)\n        ) {\n            marketDataPrev.testMarket = markets[market.baseMarketHashPrevious].testMarket;\n\n            if (!\n                (\n                    (filterTestMarkets && marketDataPrev.testMarket) ||\n                    (filterNoTradedMarkets && (marketDataPrev.userState != UserState.USER_NONE))\n                )) {\n                marketList[idx] = marketDataPrev;\n                idx++;\n            }\n\n            market = markets[market.baseMarketHashPrevious];\n            marketDataPrev = digiOptionsMarkets.getMarketData(markets[market.baseMarketHashPrevious].marketHash);\n        }\n        return marketList;\n    }\n\n    function calcBaseMarketHash (\n        MarketData memory marketData\n    ) public pure\n    returns (bytes32 baseMarketHash)\n    {\n        DigiOptionsMarkets.MarketBaseData memory marketBaseData = marketData.marketBaseData;\n\n        /* baseMarketHash is similar to marketHash but does not contain all elements. It's basically a factHash with added typeDuration */\n        return keccak256(\n            abi.encodePacked(\n                marketBaseData.baseUnitExp, /* e.g. 18 -> baseUnit = 10**18 = 1000000000000000000 */\n                marketBaseData.underlying, /* 'name' ascii encoded string as bytes32 */\n                marketBaseData.ndigit, /* 'ndigit' number of digits (may be negative) */\n                marketBaseData.objectionPeriod, /* e.g. 3600 seconds */\n                marketBaseData.expirationDatetime, /* 'settlement' unix epoch seconds UTC */\n\n                marketBaseData.typeDuration\n            )\n        );\n\n    }\n\n    function registerMarket (\n        bytes32 marketHash,\n        bool testMarket\n    ) public\n    onlyOwner // TODO remove this restriction\n    {\n        DigiOptionsMarkets.MarketData memory marketData = digiOptionsMarkets.getMarketData(marketHash);\n        DigiOptionsMarkets.MarketBaseData memory marketBaseData = marketData.marketBaseData;\n\n        assert(marketBaseData.expirationDatetime != 0);\n\n        bytes32 baseMarketHash = calcBaseMarketHash(marketData);\n\n        if (\n            ((uint256(marketBaseData.transactionFee0)).add(uint256(marketBaseData.transactionFee1)) <= transactionFeeMax) &&\n            (marketBaseData.feeTaker0 == owner)\n            // TODO check signerAddr etc (if onlyOwner is removed)\n            ){\n            if (marketsBest[baseMarketHash].openDelaySeconds == 0) {\n                // does not yet exist\n                marketsBest[baseMarketHash] = MarketBest(\n                    {\n                    marketHash: marketHash,\n                    transactionFee0: marketBaseData.transactionFee0,\n                    time: uint40(block.timestamp),\n                    openDelaySeconds: openDelaySeconds\n                    }\n                );\n\n                /* find the right place to insert */\n                Market storage market = head;\n                while (markets[market.baseMarketHashPrevious].expirationDatetime > marketBaseData.expirationDatetime) {\n                    market = markets[market.baseMarketHashPrevious];\n                }\n\n                /* using memory for struct before commiting to storage */\n                Market memory newMarket;\n\n                newMarket = Market(\n                    {\n                    marketHash: marketHash,\n                    baseMarketHashPrevious: market.baseMarketHashPrevious,\n                    /* expirationDatetime is used for sorting contracts */\n                    expirationDatetime: marketBaseData.expirationDatetime,\n                    /* only contract owner may set testMarket */\n                    testMarket: testMarket && (msg.sender == owner)\n                    }\n                );\n\n                /* insert */\n                markets[baseMarketHash] = newMarket;\n                market.baseMarketHashPrevious = baseMarketHash;\n\n                // emit only once for each market (even if it will be replaced later)\n                emit MarketCreateLister(\n                    baseMarketHash,\n                    marketBaseData.expirationDatetime,\n                    marketBaseData.underlying,\n                    marketBaseData.typeDuration,\n                    openDelaySeconds\n                );\n            } else if (\n                (marketBaseData.transactionFee0 > marketsBest[baseMarketHash].transactionFee0) &&\n                (block.timestamp <= marketsBest[baseMarketHash].time + marketsBest[baseMarketHash].openDelaySeconds)\n            ){\n                MarketBest storage marketBest = marketsBest[baseMarketHash];\n                marketBest.marketHash = marketHash;\n                marketBest.transactionFee0 = marketBaseData.transactionFee0;\n            }\n        }\n    }\n\n    // TODO: remove this function in the future\n    function createMarket (\n        DigiOptionsMarkets.MarketBaseData memory marketBaseData,\n        bool testMarket,\n        DigiOptionsMarkets.Signature memory signature\n    ) public // this should be external (see https://github.com/ethereum/solidity/issues/5479)\n    returns (bytes32 _marketHash)\n    {\n        bytes32 marketHash;\n        marketHash = digiOptionsMarkets.createMarket(\n            marketBaseData,\n            testMarket,\n            signature\n        );\n        registerMarket(\n            marketHash,\n            testMarket\n        );\n        return (marketHash);\n    }\n\n    // TODO use this?\n    function getMarketData (bytes32 marketHash)\n        public\n        view\n        returns (MarketData memory marketData_)\n    {\n        /* same as DigiOptionsMarkets' getMarketData() but with set testMarket property */\n        DigiOptionsMarkets.MarketData memory marketData = digiOptionsMarkets.getMarketData(marketHash);\n        bytes32 baseMarketHash = calcBaseMarketHash(marketData);\n        marketData.testMarket = markets[baseMarketHash].testMarket;\n\n        return marketData;\n    }\n\n    function setTestMarket (bytes32 marketHash, bool testMarket) public onlyOwner {\n        DigiOptionsMarkets.MarketData memory marketData = digiOptionsMarkets.getMarketData(marketHash);\n        bytes32 baseMarketHash = calcBaseMarketHash(marketData);\n\n        markets[baseMarketHash].testMarket = testMarket;\n    }\n\n    function setOpenDelaySeconds (uint16 openDelaySeconds_) public onlyOwner {\n        if (openDelaySeconds_ > 0) {\n            openDelaySeconds = openDelaySeconds_;\n        }\n    }\n\n    function setTransactionFeeMax (uint64 transactionFeeMax_) public onlyOwner {\n        transactionFeeMax = transactionFeeMax_;\n    }\n}\n"},"contracts/DigiOptionsBaseInterface.sol":{"content":"pragma solidity 0.5.8;\npragma experimental ABIEncoderV2;\n\n/*\n    Base data structures and the interface functions that\n    are implemente by both contracts (DigiOptionsMarkets and\n    DigioptionsMarketLister)\n*/\n\n\ncontract DigiOptionsBaseInterface {\n\n    enum ContractType {\n        CONTRACT_UNKNOWN,\n        CONTRACT_DIGIOPTIONSMARKETS, // == 1\n        CONTRACT_DIGIOPTIONSMARKETLISTER // == 2\n    }\n\n    uint256 public version;\n\n    enum UserState {USER_NONE, USER_EXISTS, USER_PAYED_OUT}\n\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct Data {\n        /* winningOptionID is only valid if settled == true */\n        uint16 winningOptionID;\n        bool settled;\n    }\n\n    struct MarketBaseData {\n        /* constant core market data, part of marketHash calculation */\n\n        bytes32 underlying;\n        uint40 expirationDatetime; /* used for sorting contracts */\n        int8 ndigit;\n        uint8 baseUnitExp;\n        uint32 objectionPeriod; /* e.g. 3600 seconds */\n\n        address signerAddr; /* address used to check the signed result (e.g. of factsigner) */\n\n        uint8 typeDuration;\n        uint64 transactionFee0; /* fee in wei for every ether of value (payed by orderTaker) */\n        address feeTaker0;\n        uint64 transactionFee1; /* fee in wei for every ether of value (payed by orderTaker) */\n        address feeTaker1;\n        int128[] strikes;\n    }\n\n    struct MarketData {\n        MarketBaseData marketBaseData;\n        Data data;\n        bytes32 marketHash;\n        UserState userState;\n        bool testMarket; // only used by MarketLister\n    }\n\n    function getContractInfo (\n    )\n        external\n        returns (\n            ContractType contractType,\n            uint256 versionMarketLister,\n            uint256 versionMarkets,\n            address digiOptionsMarketsAddr\n        );\n\n    function getMarketDataList (\n        bool filterTestMarkets, // default: true // if true all test markets are filtered out\n        bool filterNoTradedMarkets, // default: false // filter out all markets the the uses (msg.sender) has not traded\n        uint64 expirationDatetime,\n        uint16 len,\n        bytes32[] calldata marketHashLast // if list is empty we start at head - otherwise we continue to list after marketHashLast[0]\n    )\n        external\n        view\n        returns (MarketData[] memory marketList);\n\n    function createMarket (\n        MarketBaseData memory marketBaseData,\n        bool testMarket,\n        Signature memory signature\n    ) public // this should be external (see https://github.com/ethereum/solidity/issues/5479)\n        returns (bytes32 _marketHash);\n\n}\n"},"contracts/SafeCast.sol":{"content":"pragma solidity ^0.5.8;\n\n\nlibrary SafeCast {\n    /**\n     * Cast unsigned a to signed a.\n     */\n    function castToInt(uint256 a) internal pure returns(int256) {\n        assert(a < (1 << 255));\n        return int(a);\n    }\n\n    /**\n     * Cast signed a to unsigned a.\n     */\n    function castToUint(int256 a) internal pure returns(uint256) {\n        assert(a >= 0);\n        return uint(a);\n    }\n}\n"},"contracts/SafeMath.sol":{"content":"/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n */\npragma solidity ^0.5.8;\n\n\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two unsigned integers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two unsigned integers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    /*\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n    */\n\n    /* signed integer */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n        int256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        assert((b >= 0 && c <= a) || (b < 0 && c > a));\n        return c;\n    }\n\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        assert((b >= 0 && c >= a) || (b < 0 && c < a));\n        return c;\n    }\n}\n"}}}